0001                               *************************************
0002                               * COPYRIGHT (C) MOTOROLA, INC. 1979 *
0003                               *************************************
0004                               
0005                               *************************************
0006                               * THIS IS THE BASE ASSIST09 ROM.
0007                               * IT MAY RUN WITH OR WITHOUT THE
0008                               * EXTENSION ROM WHICH
0009                               * WHEN PRESENT WILL BE AUTOMATICALLY
0010                               * INCORPORATED BY THE BLDVTR
0011                               * SUBROUTINE.
0012                               *************************************
0013                               
0014                               *********************************************
0015                               * GLOBAL MODULE EQUATES
0016                               ********************************************
0017 f800                          ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
0018 ffffe700                          RAMOFS  EQU     -$1900          ; ROM OFFSET TO RAM WORK PAGE
0019 0800                          ROMSIZ  EQU     2048            ; ROM SIZE
0020 f000                          ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
0021 e008                          ACIA    EQU     $E008           ; DEFAULT ACIA ADDRESS
0022 e000                          PTM     EQU     $E000           ; DEFAULT PTM ADDRESS
0023 0000                          DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0024 0005                          DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
0025 003e                          PROMPT  EQU     '>              ; PROMPT CHARACTER
0026 0008                          NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
0027                               *********************************************
0028                               
0029                               *********************************************
0030                               * MISCELANEOUS EQUATES
0031                               *********************************************
0032 0004                          EOT     EQU     $04             ; END OF TRANSMISSION
0033 0007                          BELL    EQU     $07             ; BELL CHARACTER
0034 000a                          LF      EQU     $0A             ; LINE FEED
0035 000d                          CR      EQU     $0D             ; CARRIAGE RETURN
0036 0010                          DLE     EQU     $10             ; DATA LINK ESCAPE
0037 0018                          CAN     EQU     $18             ; CANCEL (CTL-X)
0038                               
0039                               * PTM ACCESS DEFINITIONS
0040 e001                          PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0041 e000                          PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0042 e001                          PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0043 e002                          PTMTM1  EQU     PTM+2           ; LATCH 1
0044 e004                          PTMTM2  EQU     PTM+4           ; LATCH 2
0045 e006                          PTMTM3  EQU     PTM+6           ; LATCH 3
0046 008c                          SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
0047                               
0048                               *******************************************
0049                               * ASSIST09 MONITOR SWI FUNCTIONS
0050                               * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
0051                               * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
0052                               ******************************************
0053 0000                          INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0054 0001                          OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0055 0002                          PDATA1  EQU     2               ; OUTPUT STRING
0056 0003                          PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0057 0004                          OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0058 0005                          OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0059 0006                          PCRLF   EQU     6               ; OUTPUT CR/LF
0060 0007                          SPACE   EQU     7               ; OUTPUT A SPACE
0061 0008                          MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0062 0009                          VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
0063 000a                          BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
0064 000b                          PAUSE   EQU     11              ; TASK PAUSE FUNCTION
0065 000b                          NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
0066                               
0067                               * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
0068                               * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
0069                               * RELATIVE POSITIONING MUST BE MAINTAINED
0070                               
0071 0000                          .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
0072 0002                          .CMDL1  EQU     2               ; FIRST COMMAND LIST
0073 0004                          .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0074 0006                          .SWI3   EQU     6               ; SWI3 ROUTINE
0075 0008                          .SWI2   EQU     8               ; SWI2 ROUTINE
0076 000a                          .FIRQ   EQU     10              ; FIRQ ROUTINE
0077 000c                          .IRQ    EQU     12              ; IRQ ROUTINE
0078 000e                          .SWI    EQU     14              ; SWI ROUTINE
0079 0010                          .NMI    EQU     16              ; NMI ROUTINE
0080 0012                          .RESET  EQU     18              ; RESET ROUTINE
0081 0014                          .CION   EQU     20              ; CONSOLE ON
0082 0016                          .CIDTA  EQU     22              ; CONSOLE INPUT DATA
0083 0018                          .CIOFF  EQU     24              ; CONSOLE INPUT OFF
0084 001a                          .COON   EQU     26              ; CONSOLE OUTPUT ON
0085 001c                          .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
0086 001e                          .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
0087 0020                          .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0088 0022                          .BSON   EQU     34              ; PUNCH/LOAD ON
0089 0024                          .BSDTA  EQU     36              ; PUNCH/LOAD DATA
0090 0026                          .BSOFF  EQU     38              ; PUNCH/LOAD OFF
0091 0028                          .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
0092 002a                          .EXPAN  EQU     42              ; EXPRESSION ANALYZER
0093 002c                          .CMDL2  EQU     44              ; SECOND COMMAND LIST
0094 002e                          .ACIA   EQU     46              ; ACIA ADDRESS
0095 0030                          .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0096 0032                          .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0097 0034                          .PTM    EQU     52              ; PTM ADDRESS
0098 001b                          NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0099 0034                          HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
0100                               
0101                               ******************************************
0102                               *           WORK AREA
0103                               * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
0104                               * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
0105                               * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
0106                               * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
0107                               * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
0108                               * DEFINED HEREIN.
0109                               ******************************************
0110 df00                          WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
0111                               *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
0112 e000                                  ORG     WORKPG+256      ; READY PAGE DEFINITIONS
0113                               
0114                               * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
0115                               * FOR PROPER INITIALIZATION
0116 dffc                                  ORG     *-4
0117 dffc                          PAUSER  EQU     *               ; PAUSE ROUTINE
0118 dffb                                  ORG     *-1
0119 dffb                          SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
0120 dffa                                  ORG     *-1
0121 dffa                          BKPTCT  EQU     *               ; BREAKPOINT COUNT
0122 dff8                                  ORG     *-2             ; SLEVEL EQU
0123 dff8                          SLEVEL  EQU     *               ; STACK TRACE LEVEL
0124 dfc2                                  ORG     -NUMVTR*2+*
0125 dfc2                          VECTAB  EQU     *               ; VECTOR TABLE
0126 dfb2                                  ORG     -2*NUMBKP+*
0127 dfb2                          BKPTBL  EQU     *               ; BREAKPOINT TABLE
0128 dfa2                                  ORG     -2*NUMBKP+*
0129 dfa2                          BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
0130 dfa0                                  ORG     *-2
0131 dfa0                          WINDOW  EQU     *               ; WINDOW
0132 df9e                                  ORG     *-2
0133 df9e                          ADDR    EQU     *               ; ADDRESS POINTER VALUE
0134 df9d                                  ORG     *-1
0135 df9d                          BASEPG  EQU     *               ; BASE PAGE VALUE
0136 df9b                                  ORG     *-2
0137 df9b                          NUMBER  EQU     *               ; BINARY BUILD AREA
0138 df99                                  ORG     *-2
0139 df99                          LASTOP  EQU     *               ; LAST OPCODE TRACED
0140 df97                                  ORG     *-2
0141 df97                          RSTACK  EQU     *               ; RESET STACK POINTER
0142 df95                                  ORG     *-2
0143 df95                          PSTACK  EQU     *               ; COMMAND RECOVERY STACK
0144 df93                                  ORG     *-2
0145 df93                          PCNTER  EQU     *               ; LAST PROGRAM COUNTER
0146 df91                                  ORG     *-2
0147 df91                          TRACEC  EQU     *               ; TRACE COUNT
0148 df90                                  ORG     *-1
0149 df90                          SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
0150 df8f                                  ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
0151 df8f                          MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
0152 df8e                                  ORG     *-1
0153 df8e                          DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
0154 df66                                  ORG     *-40
0155 df66                          ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
0156 df51                                  ORG     *-21
0157 df51                          TSTACK  EQU     *               ; TEMPORARY STACK HOLD
0158 df51                          STACK   EQU     *               ; START OF INITIAL STACK
0159                               
0160                               ******************************************
0161                               * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
0162                               * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
0163                               * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
0164                               * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
0165                               * FROM THE ROM BEGINNING ADDRESS.
0166                               ********************************************
0167 f800                                  ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
0168                               
0169                               *****************************************************
0170                               * BLDVTR - BUILD ASSIST09 VECTOR TABLE
0171                               * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
0172                               * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
0173                               * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
0174                               * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
0175                               * ASSIST09 EXECUTION.
0176                               * INPUT: S->VALID STACK RAM
0177                               * OUTPUT: U->VECTOR TABLE ADDRESS
0178                               * DPR->ASSIST09 WORK AREA PAGE
0179                               * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
0180                               * ALL REGISTERS VOLATILE
0181                               *************************************************
0182 f800 30 8d e7 be        [ 9 ] BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
0183 f804 1f 10              [ 6 ]         TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
0184 f806 1f 8b              [ 6 ]         TFR     A,DP            ; SETUP DPR
0185 f808 97 9d              [ 4 ]         STA     <BASEPG         ; STORE FOR QUICK REFERENCE
0186 f80a 33 84              [ 4 ]         LEAU    ,X              ; RETURN TABLE TO CALLER
0187 f80c 31 8c 35           [ 5 ]         LEAY    <INITVT,PCR     ; LOAD FROM ADDR
0188 f80f ef 81              [ 8 ]         STU     ,X++            ; INIT VECTOR TABLE ADDRESS
0189 f811 c6 16              [ 2 ]         LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
0190 f813 34 04              [ 6 ]         PSHS    B               ; STORE INDEX ON STACK
0191 f815 1f 20              [ 6 ] BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
0192 f817 e3 a1              [ 9 ]         ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
0193 f819 ed 81              [ 8 ]         STD     ,X++            ; INTO VECTOR TABLE
0194 f81b 6a e4              [ 6 ]         DEC     ,S              ; COUNT DOWN
0195 f81d 26 f6              [ 3 ]         BNE     BLD2            ; BRANCH IF MORE TO INSERT
0196 f81f c6 0d              [ 2 ]         LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
0197 f821 a6 a0              [ 6 ] BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
0198 f823 a7 80              [ 6 ]         STA     ,X+             ; STORE INTO POSITION
0199 f825 5a                 [ 2 ]         DECB                    ; COUNT DOWN
0200 f826 26 f9              [ 3 ]         BNE     BLD3            ; LOOP UNTIL DONE
0201 f828 31 8d f7 d4        [ 9 ]         LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
0202 f82c 8e 20 fe           [ 3 ]         LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
0203 f82f ac a1              [ 9 ]         CMPX    ,Y++            ; ? EXTENDED ROM HERE
0204 f831 26 02              [ 3 ]         BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
0205 f833 ad a4              [ 7 ]         JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
0206 f835 35 84              [ 8 ] BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
0207                               
0208                               *****************************************************
0209                               *                RESET ENTRY POINT
0210                               * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
0211                               * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
0212                               * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
0213                               * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
0214                               * CALL.
0215                               *******************************************************
0216 f837 32 8d e7 16        [ 9 ] RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
0217 f83b 8d c3              [ 7 ]         BSR     BLDVTR          ; BUILD VECTOR TABLE
0218 f83d 4f                 [ 2 ] RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
0219 f83e 1f 8b              [ 6 ]         TFR     A,DP            ; DEFAULT TO PAGE ZERO
0220 f840 3f                 [19 ]         SWI                     ; PERFORM MONITOR FIREUP
0221 f841 08                               FCB     MONITR          ; TO ENTER COMMAND PROCESSING
0222 f842 20 f9              [ 3 ]         BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
0223                               
0224                               ******************************************************
0225                               *        INITVT - INITIAL VECTOR TABLE
0226                               * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
0227                               * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
0228                               * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
0229                               * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
0230                               * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
0231                               ************************************************
0232 f844 01 58                    INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
0233 f846 02 92                            FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
0234 f848 02 90                            FDB     SWI3R-*         ; DEFAULT SWI3
0235 f84a 02 8e                            FDB     SWI2R-*         ; DEFAULT SWI2
0236 f84c 02 70                            FDB     FIRQR-*         ; DEFAULT FIRQ
0237 f84e 02 8a                            FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
0238 f850 00 45                            FDB     SWIR-*          ; DEFAULT SWI ROUTINE
0239 f852 02 2b                            FDB     NMIR-*          ; DEFAULT NMI ROUTINE
0240 f854 ff e3                            FDB     RESET-*         ; RESTART VECTOR
0241 f856 02 90                            FDB     CION-*          ; DEFAULT CION
0242 f858 02 84                            FDB     CIDTA-*         ; DEFAULT CIDTA
0243 f85a 02 96                            FDB     CIOFF-*         ; DEFAULT CIOFF
0244 f85c 02 8a                            FDB     COON-*          ; DEFAULT COON
0245 f85e 02 93                            FDB     CODTA-*         ; DEFAULT CODTA
0246 f860 02 90                            FDB     COOFF-*         ; DEFAULT COOFF
0247 f862 03 9a                            FDB     HSDTA-*         ; DEFAULT HSDTA
0248 f864 02 b7                            FDB     BSON-*          ; DEFAULT BSON
0249 f866 02 d2                            FDB     BSDTA-*         ; DEFAULT BSDTA
0250 f868 02 bf                            FDB     BSOFF-*         ; DEFAULT BSOFF
0251 f86a e7 92                            FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
0252 f86c 04 7d                            FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
0253 f86e 01 2d                            FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
0254                               * CONSTANTS
0255 f870 e0 08                    INTVS   FDB     ACIA            ; DEFAULT ACIA
0256 f872 00 05                            FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
0257 f874 00 00                            FDB     0               ; DEFAULT ECHO
0258 f876 e0 00                            FDB     PTM             ; DEFAULT PTM
0259 f878 00 00                            FDB     0               ; INITIAL STACK TRACE LEVEL
0260 f87a 00                               FCB     0               ; INITIAL BREAKPOINT COUNT
0261 f87b 00                               FCB     0               ; SWI BREAKPOINT LEVEL
0262 f87c 39                               FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
0263 f87d                          INTVE   EQU     *
0264                               *B
0265                               ***********************************************
0266                               *            ASSIST09 SWI HANDLER
0267                               * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
0268                               * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
0269                               * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
0270                               * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
0271                               * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
0272                               * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
0273                               * INPUT: MACHINE STATE DEFINED FOR SWI
0274                               * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
0275                               * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
0276                               * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
0277                               * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
0278                               ************************************************
0279                               * SWI FUNCTION VECTOR TABLE
0280 f87d 01 94                    SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
0281 f87f 01 b1                            FDB     ZOTCH1-SWIVTB   ; OUTCH
0282 f881 01 cb                            FDB     ZPDTA1-SWIVTB   ; PDATA1
0283 f883 01 c3                            FDB     ZPDATA-SWIVTB   ; PDATA
0284 f885 01 75                            FDB     ZOT2HS-SWIVTB   ; OUT2HS
0285 f887 01 73                            FDB     ZOT4HS-SWIVTB   ; OUT4HS
0286 f889 01 c0                            FDB     ZPCRLF-SWIVTB   ; PCRLF
0287 f88b 01 79                            FDB     ZSPACE-SWIVTB   ; SPACE
0288 f88d 00 55                            FDB     ZMONTR-SWIVTB   ; MONITR
0289 f88f 01 7d                            FDB     ZVSWTH-SWIVTB   ; VCTRSW
0290 f891 02 56                            FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
0291 f893 01 d1                            FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
0292                               
0293 f895 6a 8d e6 f7        [11 ] SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
0294 f899 17 02 25           [ 9 ]         LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
0295                               * CHECK FOR BREAKPOINT TRAP
0296 f89c ee 6a              [ 6 ]         LDU     10,S            ; LOAD PROGRAM COUNTER
0297 f89e 33 5f              [ 5 ]         LEAU    -1,U            ; BACK TO SWI ADDRESS
0298 f8a0 0d fb              [ 6 ]         TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
0299 f8a2 26 11              [ 3 ]         BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
0300 f8a4 17 06 9b           [ 9 ]         LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0301 f8a7 50                 [ 2 ]         NEGB                    ; OBTAIN POSITIVE COUNT
0302 f8a8 5a                 [ 2 ] SWILP   DECB                    ; COUNT DOWN
0303 f8a9 2b 0a              [ 3 ]         BMI     SWIDNE          ; BRANCH WHEN DONE
0304 f8ab 11 a3 a1           [10 ]         CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
0305 f8ae 26 f8              [ 3 ]         BNE     SWILP           ; BRANCH IF NOT
0306 f8b0 ef 6a              [ 6 ]         STU     10,S            ; SET PROGRAM COUNTER BACK
0307 f8b2 16 02 1e           [ 5 ]         LBRA    ZBKPNT          ; GO DO BREAKPOINT
0308 f8b5 0f fb              [ 6 ] SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
0309 f8b7 37 06              [ 7 ]         PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
0310 f8b9 c1 0b              [ 2 ]         CMPB    #NUMFUN         ; ? TOO HIGH
0311 f8bb 10 22 02 0f        [ 6 ]         LBHI    ERROR           ; YES, DO BREAKPOINT
0312 f8bf ef 6a              [ 6 ]         STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
0313 f8c1 58                 [ 2 ]         ASLB                    ; FUNCTION CODE TIMES TWO
0314 f8c2 33 8c b8           [ 5 ]         LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
0315 f8c5 ec c5              [ 6 ]         LDD     B,U             ; LOAD OFFSET
0316 f8c7 6e cb              [ 7 ]         JMP     D,U             ; JUMP TO ROUTINE
0317                               
0318                               **********************************************
0319                               * REGISTERS TO FUNCTION ROUTINES:
0320                               *  DP-> WORK AREA PAGE
0321                               *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
0322                               *  S=AS FROM SWI INTERRUPT
0323                               *********************************************
0324                               
0325                               **************************************************
0326                               *            [SWI FUNCTION 8]
0327                               *              MONITOR ENTRY
0328                               *  FIREUP THE ASSIST09 MONITOR.
0329                               *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
0330                               *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
0331                               *   1) INITIALIZE CONSOLE I/O
0332                               *   2) OPTIONALLY PRINT SIGNON
0333                               *   3) INITIALIZE PTM FOR SINGLE STEPPING
0334                               *   4) ENTER COMMAND PROCESSOR
0335                               * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
0336                               *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
0337                               *************************************************
0338                               
0339 f8c9 41 53 53 49 53 54        SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
0340 f8d1 04                               FCB     EOT
0341 f8d2 10 df 97           [ 6 ] ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
0342 f8d5 6d 61              [ 7 ]         TST     1,S             ; ? INIT CONSOLE AND SEND MSG
0343 f8d7 26 0d              [ 3 ]         BNE     ZMONT2          ; BRANCH IF NOT
0344 f8d9 ad 9d e6 f9        [15 ]         JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
0345 f8dd ad 9d e6 fb        [15 ]         JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
0346 f8e1 30 8c e5           [ 5 ]         LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
0347 f8e4 3f                 [19 ]         SWI                     ; PERFORM
0348 f8e5 03                               FCB     PDATA           ; PRINT STRING
0349 f8e6 9e f6              [ 5 ] ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
0350 f8e8 27 0d              [ 3 ]         BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
0351 f8ea 6f 02              [ 7 ]         CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
0352 f8ec 6f 03              [ 7 ]         CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
0353 f8ee cc 01 a6           [ 3 ]         LDD     #$01A6          ; SETUP TIMER 1 MODE
0354 f8f1 a7 01              [ 5 ]         STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
0355 f8f3 e7 84              [ 4 ]         STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
0356                               * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
0357 f8f5 6f 01              [ 7 ]         CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
0358                               * FALL INTO COMMAND PROCESSOR
0359                               
0360                               ***************************************************
0361                               *          COMMAND HANDLER
0362                               *  BREAKPOINTS ARE REMOVED AT THIS TIME.
0363                               *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
0364                               *  UNTIL A SEPARATOR ON THE STACK.
0365                               *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
0366                               *  CALL IT OR GIVE '?' RESPONSE.
0367                               *  DURING COMMAND SEARCH:
0368                               *      B=OFFSET TO NEXT ENTRY ON X
0369                               *      U=SAVED S
0370                               *      U-1=ENTRY SIZE+2
0371                               *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
0372                               *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
0373                               *      U-4=START OF COMMAND STORE
0374                               *      S+0=END OF COMMAND STORE
0375                               ***********************************************
0376                               
0377 f8f7 3f                 [19 ] CMD     SWI                     ; TO NEW LINE
0378 f8f8 06                               FCB     PCRLF           ; FUNCTION
0379                               * DISARM THE BREAKPOINTS
0380 f8f9 17 06 46           [ 9 ] CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0381 f8fc 2a 0c              [ 3 ]         BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
0382 f8fe 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
0383 f8ff d7 fa              [ 4 ]         STB     <BKPTCT         ; FLAG AS DISARMED
0384 f901 5a                 [ 2 ] CMDDDL  DECB                    ; ? FINISHED
0385 f902 2b 06              [ 3 ]         BMI     CMDNOL          ; BRANCH IF SO
0386 f904 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
0387 f906 a7 b1              [10 ]         STA     [,Y++]          ; STORE BACK OVER "SWI"
0388 f908 20 f7              [ 3 ]         BRA     CMDDDL          ; LOOP UNTIL DONE
0389 f90a ae 6a              [ 6 ] CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
0390 f90c 9f 93              [ 5 ]         STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
0391 f90e 86 3e              [ 2 ]         LDA     #PROMPT         ; LOAD PROMPT CHARACTER
0392 f910 3f                 [19 ]         SWI                     ; SEND TO OUTPUT HANDLER
0393 f911 01                               FCB     OUTCH           ; FUNCTION
0394 f912 33 e4              [ 4 ]         LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
0395 f914 df 95              [ 5 ]         STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
0396 f916 4f                 [ 2 ]         CLRA                    ; PREPARE ZERO
0397 f917 5f                 [ 2 ]         CLRB                    ; PREPARE ZERO
0398 f918 dd 9b              [ 5 ]         STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
0399 f91a dd 8f              [ 5 ]         STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
0400 f91c dd 91              [ 5 ]         STD     <TRACEC         ; CLEAR TRACE COUNT
0401 f91e c6 02              [ 2 ]         LDB     #2              ; SET D TO TWO
0402 f920 34 07              [ 8 ]         PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
0403                               * CHECK FOR "QUICK" COMMANDS.
0404 f922 17 04 54           [ 9 ]         LBSR    READ            ; OBTAIN FIRST CHARACTER
0405 f925 30 8d 05 81        [ 9 ]         LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
0406 f929 81 2e              [ 2 ]         CMPA    #'.             ; ? QUICK TRACE
0407 f92b 27 5a              [ 3 ]         BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
0408 f92d 30 8d 04 e9        [ 9 ]         LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
0409 f931 81 2f              [ 2 ]         CMPA    #'/             ; ? OPEN LAST USED MEMORY
0410 f933 27 52              [ 3 ]         BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
0411                               * PROCESS NEXT CHARACTER
0412 f935 81 20              [ 2 ] CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
0413 f937 23 14              [ 3 ]         BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
0414 f939 34 02              [ 6 ]         PSHS   A                ; BUILD ONTO STACK
0415 f93b 6c 5f              [ 7 ]         INC    -1,U             ; COUNT THIS CHARACTER
0416 f93d 81 2f              [ 2 ]         CMPA   #'/              ; ? MEMORY COMMAND
0417 f93f 27 4f              [ 3 ]         BEQ    CMDMEM           ; BRANCH IF SO
0418 f941 17 04 0b           [ 9 ]         LBSR   BLDHXC           ; TREAT AS HEX VALUE
0419 f944 27 02              [ 3 ]         BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
0420 f946 6a 5e              [ 7 ]         DEC    -2,U             ; FLAG AS INVALID NUMBER
0421 f948 17 04 2e           [ 9 ] CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
0422 f94b 20 e8              [ 3 ]         BRA    CMD2             ; TEST NEXT CHARACTER
0423                               * GOT COMMAND, NOW SEARCH TABLES
0424 f94d 80 0d              [ 2 ] CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
0425 f94f a7 5d              [ 5 ]         STA    -3,U             ; SETUP FLAG
0426 f951 9e c4              [ 5 ]         LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
0427 f953 e6 80              [ 6 ] CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
0428 f955 2a 10              [ 3 ]         BPL    CMDSME           ; BRANCH IF NOT LIST END
0429 f957 9e ee              [ 5 ]         LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
0430 f959 5c                 [ 2 ]         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
0431 f95a 27 f7              [ 3 ]         BEQ     CMDSCH          ; BRANCH IF SO
0432 f95c 10 de 95           [ 6 ] CMDBAD  LDS     <PSTACK         ; RESTORE STACK
0433 f95f 30 8d 01 5a        [ 9 ]         LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
0434 f963 3f                 [19 ]         SWI                     ; SEND OUT
0435 f964 02                               FCB     PDATA1          ; TO CONSOLE
0436 f965 20 90              [ 3 ]         BRA     CMD             ; AND TRY AGAIN
0437                               * SEARCH NEXT ENTRY
0438 f967 5a                 [ 2 ] CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
0439 f968 e1 5f              [ 5 ]         CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
0440 f96a 24 03              [ 3 ]         BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
0441 f96c 3a                 [ 3 ] CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
0442 f96d 20 e4              [ 3 ]         BRA     CMDSCH          ; AND TRY NEXT
0443 f96f 31 5d              [ 5 ] CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
0444 f971 a6 5f              [ 5 ]         LDA     -1,U            ; LOAD SIZE+2
0445 f973 80 02              [ 2 ]         SUBA    #2              ; TO ACTUAL SIZE ENTERED
0446 f975 a7 5e              [ 5 ]         STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
0447 f977 5a                 [ 2 ] CMDCMP  DECB                    ; DOWN ONE BYTE
0448 f978 a6 80              [ 6 ]         LDA     ,X+             ; NEXT COMMAND CHARACTER
0449 f97a a1 a2              [ 6 ]         CMPA    ,-Y             ; ? SAME AS THAT ENTERED
0450 f97c 26 ee              [ 3 ]         BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
0451 f97e 6a 5e              [ 7 ]         DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
0452 f980 26 f5              [ 3 ]         BNE     CMDCMP          ; BRANCH IF MORE TO TEST
0453 f982 3a                 [ 3 ]         ABX                     ; TO NEXT ENTRY
0454 f983 ec 1e              [ 6 ]         LDD     -2,X            ; LOAD OFFSET
0455 f985 30 8b              [ 8 ]         LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
0456 f987 6d 5d              [ 7 ] CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
0457 f989 32 c4              [ 4 ]         LEAS    ,U              ; DELETE STACK WORK AREA
0458 f98b ad 1e              [ 8 ]         JSR     -2,X            ; CALL COMMAND
0459 f98d 16 ff 7a           [ 5 ]         LBRA    CMDNOL          ; GO GET NEXT COMMAND
0460 f990 6d 5e              [ 7 ] CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
0461 f992 2b c8              [ 3 ]         BMI     CMDBAD          ; BRANCH ERROR IF NOT
0462 f994 30 88 ae           [ 5 ]         LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
0463 f997 dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER ENTERED
0464 f999 20 ec              [ 3 ]         BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
0465                               
0466                               ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
0467                               **    DPR->ASSIST09 DIRECT PAGE WORK AREA
0468                               **    Z=1 CARRIAGE RETURN ENTERED
0469                               **    Z=0 NON CARRIAGE RETURN DELIMITER
0470                               **    S=NORMAL RETURN ADDRESS
0471                               ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
0472                               ** AN ERROR FLAG (*).
0473                               **************************************************
0474                               *       ASSIST09 COMMAND TABLES
0475                               * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
0476                               * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
0477                               * THESE BY USING THE VECTOR SWAP FUNCTION.
0478                               *
0479                               * ENTRY FORMAT:
0480                               *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
0481                               *    +1...COMMAND STRING
0482                               *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
0483                               *
0484                               * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
0485                               * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
0486                               *        SECOND COMMAND TABLE.
0487                               * THE -2 TERMINATES COMMAND SEARCHES.
0488                               *****************************************************
0489                               
0490                               * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
0491                               * LIST ENTRY.
0492                               
0493 f99b fe                       CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
0494                               
0495                               * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
0496                               * LIST ENTRY.
0497                               
0498 f99c                          CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
0499 f99c 04                               FCB     4
0500 f99d 42                               FCC     /B/             ; 'BREAKPOINT' COMMAND
0501 f99e 05 4d                            FDB     CBKPT-*
0502 f9a0 04                               FCB     4
0503 f9a1 43                               FCC     /C/             ; 'CALL' COMMAND
0504 f9a2 04 17                            FDB     CCALL-*
0505 f9a4 04                               FCB     4
0506 f9a5 44                               FCC     /D/             ; 'DISPLAY' COMMAND
0507 f9a6 04 9d                            FDB     CDISP-*
0508 f9a8 04                               FCB     4
0509 f9a9 45                               FCC     /E/             ; 'ENCODE' COMMAND
0510 f9aa 05 9f                            FDB     CENCDE-*
0511 f9ac 04                               FCB     4
0512 f9ad 47                               FCC     /G/             ; 'GO' COMMAND
0513 f9ae 03 d2                            FDB     CGO-*
0514 f9b0 04                               FCB     4
0515 f9b1 4c                               FCC     /L/             ; 'LOAD' COMMAND
0516 f9b2 04 dd                            FDB     CLOAD-*
0517 f9b4 04                               FCB     4
0518 f9b5 4d                               FCC     /M/             ; 'MEMORY' COMMAND
0519 f9b6 04 0d                            FDB     CMEM-*
0520 f9b8 04                               FCB     4
0521 f9b9 4e                               FCC     /N/             ; 'NULLS' COMMAND
0522 f9ba 04 fd                            FDB     CNULLS-*
0523 f9bc 04                               FCB     4
0524 f9bd 4f                               FCC     /O/             ; 'OFFSET' COMMAND
0525 f9be 05 0a                            FDB     COFFS-*
0526 f9c0 04                               FCB     4
0527 f9c1 50                               FCC     /P/             ; 'PUNCH' COMMAND
0528 f9c2 04 af                            FDB     CPUNCH-*
0529 f9c4 04                               FCB     4
0530 f9c5 52                               FCC     /R/             ; 'REGISTERS' COMMAND
0531 f9c6 02 84                            FDB     CREG-*
0532 f9c8 04                               FCB     4
0533 f9c9 53                               FCC     /S/             ; 'STLEVEL' COMMAND
0534 f9ca 04 f2                            FDB     CSTLEV-*
0535 f9cc 04                               FCB     4
0536 f9cd 54                               FCC     /T/             ; 'TRACE' COMMAND
0537 f9ce 04 d6                            FDB     CTRACE-*
0538 f9d0 04                               FCB     4
0539 f9d1 56                               FCC     /V/             ; 'VERIFY' COMMAND
0540 f9d2 04 cf                            FDB     CVER-*
0541 f9d4 04                               FCB     4
0542 f9d5 57                               FCC     /W/             ; 'WINDOW' COMMAND
0543 f9d6 04 68                            FDB     CWINDO-*
0544 f9d8 ff                               FCB     -1              ; END, CONTINUE WITH THE SECOND
0545                               
0546                               *************************************************
0547                               *             [SWI FUNCTIONS 4 AND 5]
0548                               *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
0549                               *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
0550                               * INPUT: X->BYTE OR WORD TO DECODE
0551                               * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
0552                               *         X->NEXT BYTE OR WORD
0553                               *************************************************
0554 f9d9 a6 80              [ 6 ] ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
0555 f9db 34 06              [ 7 ]         PSHS    D               ; SAVE - DO NOT REREAD
0556 f9dd c6 10              [ 2 ]         LDB     #16             ; SHIFT BY 4 BITS
0557 f9df 3d                 [11 ]         MUL                     ; WITH MULTIPLY
0558 f9e0 8d 04              [ 7 ]         BSR     ZOUTHX          ; SEND OUT AS HEX
0559 f9e2 35 06              [ 7 ]         PULS    D               ; RESTORE BYTES
0560 f9e4 84 0f              [ 2 ]         ANDA    #$0F            ; ISOLATE RIGHT HEX
0561 f9e6 8b 90              [ 2 ] ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
0562 f9e8 19                 [ 2 ]         DAA                     ; ADJUST
0563 f9e9 89 40              [ 2 ]         ADCA    #$40            ; PREPARE CHARACTER BITS
0564 f9eb 19                 [ 2 ]         DAA                     ; ADJUST
0565 f9ec 6e 9d e5 ee        [11 ] SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
0566                               
0567 f9f0 8d e7              [ 7 ] ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
0568 f9f2 8d e5              [ 7 ] ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
0569 f9f4 af 64              [ 6 ]         STX     4,S             ; UPDATE USERS X REGISTER
0570                               * FALL INTO SPACE ROUTINE
0571                               
0572                               *************************************************
0573                               *            [SWI FUNCTION 7]
0574                               *         SPACE - SEND BLANK TO OUTPUT HANDLER
0575                               * INPUT: NONE
0576                               * OUTPUT: BLANK SEND TO CONSOLE HANDLER
0577                               *************************************************
0578 f9f6 86 20              [ 2 ] ZSPACE  LDA     #'              ; LOAD BLANK
0579 f9f8 20 3d              [ 3 ]         BRA     ZOTCH2          ; SEND AND RETURN
0580                               
0581                               ***********************************************
0582                               *             [SWI FUNCTION 9]
0583                               *          SWAP VECTOR TABLE ENTRY
0584                               * INPUT: A=VECTOR TABLE CODE (OFFSET)
0585                               * X=0 OR REPLACEMENT VALUE
0586                               * OUTPUT: X=PREVIOUS VALUE
0587                               ***********************************************
0588 f9fa a6 61              [ 5 ] ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
0589 f9fc 81 34              [ 2 ]         CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
0590 f9fe 22 39              [ 3 ]         BHI     ZOTCH3          ; IGNORE CALL IF SO
0591 fa00 10 9e c2           [ 6 ]         LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
0592 fa03 ee a6              [ 6 ]         LDU     A,Y             ; U=OLD ENTRY
0593 fa05 ef 64              [ 6 ]         STU     4,S             ; RETURN OLD VALUE TO CALLERS X
0594 fa07 af 7e              [ 6 ]         STX     -2,S            ; ? X=0
0595 fa09 27 2e              [ 3 ]         BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
0596 fa0b af a6              [ 6 ]         STX     A,Y             ; REPLACE ENTRY
0597 fa0d 20 2a              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM SWI
0598                               *D
0599                               
0600                               ************************************************
0601                               *               [SWI FUNCTION 0]
0602                               *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
0603                               * NULLS AND RUBOUTS ARE IGNORED.
0604                               * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
0605                               * CARRIAGE RETURN.
0606                               * UNLESS WE ARE LOADING FROM TAPE.
0607                               ************************************************
0608 fa0f 8d 5d              [ 7 ] ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
0609 fa11 8d 5f              [ 7 ] ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
0610 fa13 24 fa              [ 3 ]         BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
0611 fa15 4d                 [ 2 ]         TSTA                    ; ? TEST FOR NULL
0612 fa16 27 f9              [ 3 ]         BEQ     ZINCH           ; IGNORE NULL
0613 fa18 81 7f              [ 2 ]         CMPA    #$7F            ; ? RUBOUT
0614 fa1a 27 f5              [ 3 ]         BEQ     ZINCH           ; BRANCH YES TO IGNORE
0615 fa1c a7 61              [ 5 ]         STA     1,S             ; STORE INTO CALLERS A
0616 fa1e 0d 8f              [ 6 ]         TST     <MISFLG         ; ? LOAD IN PROGRESS
0617 fa20 26 17              [ 3 ]         BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
0618 fa22 81 0d              [ 2 ]         CMPA    #CR             ; ? CARRIAGE RETURN
0619 fa24 26 04              [ 3 ]         BNE     ZIN2            ; NO, TEST ECHO BYTE
0620 fa26 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0621 fa28 8d c2              [ 7 ]         BSR     SEND            ; ALWAYS ECHO LINE FEED
0622 fa2a 0d f4              [ 6 ] ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
0623 fa2c 26 0b              [ 3 ]         BNE     ZOTCH3          ; NO, RETURN
0624                               * FALL THROUGH TO OUTCH
0625                               ************************************************
0626                               *            [SWI FUNCTION 1]
0627                               *        OUTCH - OUTPUT CHARACTER FROM A
0628                               * INPUT: NONE
0629                               * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
0630                               * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
0631                               ************************************************
0632 fa2e a6 61              [ 5 ] ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
0633 fa30 30 8c 09           [ 5 ]         LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
0634 fa33 81 0a              [ 2 ]         CMPA    #LF             ; ? LINE FEED
0635 fa35 27 0f              [ 3 ]         BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
0636 fa37 8d b3              [ 7 ] ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
0637 fa39 0c 90              [ 6 ] ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
0638 fa3b 3b                 [15 ]         RTI                     ; RETURN FROM "SWI" FUNCTION
0639                               
0640                               **************************************************
0641                               * [SWI FUNCTION 6]
0642                               * PCRLF - SEND CR/LF TO CONSOLE HANDLER
0643                               * INPUT: NONE
0644                               * OUTPUT: CR AND LF SENT TO HANDLER
0645                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0646                               **************************************************
0647 fa3c 04                       ZPCRLS  FCB     EOT             ; NULL STRING
0648 fa3d 30 8c fc           [ 5 ] ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
0649                               * FALL INTO CR/LF CODE
0650                               
0651                               **************************************************
0652                               * [SWI FUNCTION 3]
0653                               * PDATA - OUTPUT CR/LF AND STRING
0654                               * INPUT: X->STRING
0655                               * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
0656                               * HANDLER.
0657                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0658                               * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
0659                               * PROPER PUNCH DATA.
0660                               **************************************************
0661                               
0662 fa40 86 0d              [ 2 ] ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
0663 fa42 8d a8              [ 7 ]         BSR     SEND            ; SEND IT
0664 fa44 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0665                               * FALL INTO PDATA1
0666                               
0667                               *************************************************
0668                               * [SWI FUNCTION 2]
0669                               * PDATA1 - OUTPUT STRING TILL EOT ($04)
0670                               * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
0671                               * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
0672                               * SECOND IS RECEIVED.
0673                               * INPUT: X->STRING
0674                               * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
0675                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0676                               *************************************************
0677                               
0678 fa46 8d a4              [ 7 ] ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
0679 fa48 a6 80              [ 6 ] ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
0680 fa4a 81 04              [ 2 ]         CMPA    #EOT            ; ? EOT
0681 fa4c 26 f8              [ 3 ]         BNE     ZPDTLP          ; LOOP IF NOT
0682                               * FALL INTO PAUSE CHECK FUNCTION
0683                               
0684                               ********************************************
0685                               * [SWI FUNCTION 12]
0686                               * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
0687                               * FOR FREEZE CONDITION OR CTL-X BREAK
0688                               * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
0689                               * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
0690                               * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
0691                               * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
0692                               * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
0693                               * HANDLER.
0694                               * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
0695                               ******************************************
0696                               
0697 fa4e 8d 1e              [ 7 ] ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
0698 fa50 8d 06              [ 7 ]         BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
0699 fa52 1f a9              [ 6 ]         TFR     CC,B            ; PREPARE TO REPLACE CC
0700 fa54 e7 e4              [ 4 ]         STB     ,S              ; OVERLAY OLD ONE ON STACK
0701 fa56 20 e1              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM "SWI"
0702                               
0703                               * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
0704                               * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
0705                               * VOLATILE: U,X,D
0706 fa58 8d 18              [ 7 ] CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
0707 fa5a 24 05              [ 3 ]         BCC     CHKRTN          ; BRANCH NO TO RETURN
0708 fa5c 81 18              [ 2 ]         CMPA    #CAN            ; ? CTL-X FOR ABORT
0709 fa5e 26 02              [ 3 ]         BNE     CHKWT           ; BRANCH NO TO PAUSE
0710 fa60 53                 [ 2 ] CHKSEC  COMB                    ; SET CARRY
0711 fa61 39                 [ 5 ] CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
0712 fa62 8d 0a              [ 7 ] CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
0713 fa64 8d 0c              [ 7 ]         BSR     XQCIDT          ; ? KEY FOR START
0714 fa66 24 fa              [ 3 ]         BCC     CHKWT           ; LOOP UNTIL RECEIVED
0715 fa68 81 18              [ 2 ]         CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
0716 fa6a 27 f4              [ 3 ]         BEQ     CHKSEC          ; BRANCH YES
0717 fa6c 4f                 [ 2 ]         CLRA                    ; SET C=0 FOR NO ABORT
0718 fa6d 39                 [ 5 ]         RTS                     ; AND RETURN
0719                               
0720                               * SAVE MEMORY WITH JUMPS
0721 fa6e 6e 9d e5 78        [11 ] XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
0722 fa72 ad 9d e5 62        [15 ] XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
0723 fa76 84 7f              [ 2 ]         ANDA  #$7F              ; STRIP PARITY
0724 fa78 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0725                               
0726                               ********************************************
0727                               * NMI DEFAULT INTERRUPT HANDLER
0728                               * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
0729                               * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
0730                               * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
0731                               * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
0732                               * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
0733                               *********************************************
0734                               
0735 fa79 4f 50 2d 04              MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
0736                               
0737 fa7d 8d 42              [ 7 ] NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
0738 fa7f 0d 8f              [ 6 ]         TST     <MISFLG         ; ? THRU A BREAKPOINT
0739 fa81 26 34              [ 3 ]         BNE     NMICON          ; BRANCH IF SO TO CONTINUE
0740 fa83 0d 90              [ 6 ]         TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
0741 fa85 2b 29              [ 3 ]         BMI     NMITRC          ; BRANCH YES
0742 fa87 30 6c              [ 5 ]         LEAX    12,S            ; OBTAIN USERS STACK POINTER
0743 fa89 9c f8              [ 6 ]         CMPX    <SLEVEL         ; ? TO TRACE HERE
0744 fa8b 25 23              [ 3 ]         BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
0745 fa8d 30 8c e9           [ 5 ]         LEAX    MSHOWP,PCR      ; LOAD OP PREP
0746 fa90 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
0747 fa91 02                               FCB     PDATA1          ; FUNCTION
0748 fa92 09 8e              [ 6 ]         ROL     <DELIM          ; SAVE CARRY BIT
0749 fa94 30 8d e5 01        [ 9 ]         LEAX    LASTOP,PCR      ; POINT TO LAST OP
0750 fa98 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
0751 fa99 05                               FCB     OUT4HS          ; FUNCTION
0752 fa9a 8d 17              [ 7 ]         BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
0753 fa9c 25 37              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0754 fa9e 06 8e              [ 6 ]         ROR     <DELIM          ; RESTORE CARRY BIT
0755 faa0 25 33              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0756 faa2 9e 91              [ 5 ]         LDX     <TRACEC         ; LOAD TRACE COUNT
0757 faa4 27 2f              [ 3 ]         BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
0758 faa6 30 1f              [ 5 ]         LEAX    -1,X            ; MINUS ONE
0759 faa8 9f 91              [ 5 ]         STX     <TRACEC         ; REFRESH
0760 faaa 27 29              [ 3 ]         BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
0761 faac 8d aa              [ 7 ]         BSR     CHKABT          ; ? ABORT THE TRACE
0762 faae 25 25              [ 3 ]         BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
0763 fab0 16 03 f7           [ 5 ] NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
0764                               
0765 fab3 17 01 b9           [ 9 ] REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
0766 fab6 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0767                               
0768                               * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
0769                               
0770 fab7 0f 8f              [ 6 ] NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
0771 fab9 17 02 eb           [ 9 ]         LBSR    ARMBK2         ; ARM BREAKPOINTS
0772 fabc 3b                 [15 ] RTI     RTI                    ; AND CONTINUE USERS PROGRAM
0773                               
0774                               * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
0775                               * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
0776                               * HANDLER.
0777                               * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
0778                               * OUTPUT: DPR LOADED TO WORK PAGE
0779                               
0780 fabd 3f 07 20 04              ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
0781                               
0782 fac1 e6 8d e4 d8        [ 9 ] LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
0783 fac5 1f 9b              [ 6 ]         TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
0784 fac7 a1 63              [ 5 ]         CMPA    3,S             ; ? IS STACK VALID
0785 fac9 27 25              [ 3 ]         BEQ     RTS             ; YES, RETURN
0786 facb 10 de 97           [ 6 ]         LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
0787 face 30 8c ec           [ 5 ] ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
0788 fad1 3f                 [19 ]         SWI                     ; SEND OUT BEFORE REGISTERS
0789 fad2 03                               FCB     PDATA           ; ON NEXT LINE
0790                               * FALL INTO BREAKPOINT HANDLER
0791                               
0792                               **********************************************
0793                               * [SWI FUNCTION 10]
0794                               * BREAKPOINT PROGRAM FUNCTION
0795                               * PRINT REGISTERS AND GO TO COMMAND HANLER
0796                               ***********************************************
0797                               
0798 fad3 8d de              [ 7 ] ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
0799 fad5 16 fe 21           [ 5 ] ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
0800                               
0801                               ********************************************
0802                               * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
0803                               * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
0804                               ********************************************
0805 fad8                          SWI2R   EQU     *               ; SWI2 ENTRY
0806 fad8                          SWI3R   EQU     *               ; SWI3 ENTRY
0807 fad8                          IRQR    EQU     *               ; IRQ ENTRY
0808 fad8 8d e7              [ 7 ] RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
0809 fada 20 f7              [ 3 ]         BRA     ZBKPNT          ; FORCE A BREAKPOINT
0810                               
0811                               ******************************************
0812                               * FIRQ HANDLER
0813                               * JUST RETURN FOR THE FIRQ INTERRUPT
0814                               ******************************************
0815 fabc                          FIRQR   EQU     RTI             ; IMMEDIATE RETURN
0816                               
0817                               **************************************************
0818                               * DEFAULT I/O DRIVERS
0819                               **************************************************
0820                               * CIDTA - RETURN CONSOLE INPUT CHARACTER
0821                               * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
0822                               * U VOLATILE
0823                               
0824 fadc de f0              [ 5 ] CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0825 fade a6 c4              [ 4 ]         LDA     ,U              ; LOAD STATUS REGISTER
0826 fae0 44                 [ 2 ]         LSRA                    ; TEST RECEIVER REGISTER FLAG
0827 fae1 24 02              [ 3 ]         BCC     CIRTN           ; RETURN IF NOTHING
0828 fae3 a6 41              [ 5 ]         LDA     1,U             ; LOAD DATA BYTE
0829 fae5 39                 [ 5 ] CIRTN   RTS                     ; RETURN TO CALLER
0830                               
0831                               * CION - INPUT CONSOLE INITIALIZATION
0832                               * COON - OUTPUT CONSOLE INITIALIZATION
0833                               * A,X VOLATILE
0834 fae6                          CION   EQU      *
0835 fae6 86 03              [ 2 ] COON   LDA      #3              ; RESET ACIA CODE
0836 fae8 9e f0              [ 5 ]        LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0837 faea a7 84              [ 4 ]        STA      ,X              ; STORE INTO STATUS REGISTER
0838 faec 86 51              [ 2 ]        LDA      #$51            ; SET CONTROL
0839 faee a7 84              [ 4 ]        STA      ,X              ; REGISTER UP
0840 faf0 39                 [ 5 ] RTS    RTS                      ; RETURN TO CALLER
0841                               
0842                               * THE FOLLOWING HAVE NO DUTIES TO PERFORM
0843 faf0                          CIOFF EQU       RTS             ; CONSOLE INPUT OFF
0844 faf0                          COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
0845                               
0846                               * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
0847                               * INPUT: A=CHARACTER TO SEND
0848                               * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
0849                               * ALL REGISTERS TRANSPARENT
0850                               
0851 faf1 34 47              [10 ] CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
0852 faf3 de f0              [ 5 ]         LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
0853 faf5 8d 1b              [ 7 ]         BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
0854 faf7 81 10              [ 2 ]         CMPA    #DLE            ; ? DATA LINE ESCAPE
0855 faf9 27 12              [ 3 ]         BEQ     CODTRT          ; YES, RETURN
0856 fafb d6 f2              [ 4 ]         LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
0857 fafd 81 0d              [ 2 ]         CMPA    #CR             ; ? CR
0858 faff 26 02              [ 3 ]         BNE     CODTPD          ; BRANCH NO
0859 fb01 d6 f3              [ 4 ]         LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
0860 fb03 4f                 [ 2 ] CODTPD  CLRA                    ; CREATE NULL
0861 fb04 e7 e4              [ 4 ]         STB     ,S              ; SAVE COUNT
0862 fb06 8c                               FCB     SKIP2           ; ENTER LOOP
0863 fb07 8d 09              [ 7 ] CODTLP  BSR     CODTAO          ; SEND NULL
0864 fb09 6a e4              [ 6 ]         DEC     ,S              ; ? FINISHED
0865 fb0b 2a fa              [ 3 ]         BPL     CODTLP          ; NO, CONTINUE WITH MORE
0866 fb0d 35 c7              [12 ] CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
0867                               
0868 fb0f 17 ff 5c           [ 9 ] CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
0869 fb12 e6 41              [ 5 ] CODTAO  LDB     1,U             ; LOAD ACIA CONTROL REGISTER
0870 fb14 c5 02              [ 2 ]         BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
0871 fb16 26 f7              [ 3 ]         BNE     CODTAD          ; RELEASE CONTROL IF NOT
0872 fb18 a7 c4              [ 4 ]         STA     ,U              ; STORE INTO DATA REGISTER
0873 fb1a 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0874                               *E
0875                               
0876                               * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
0877                               * A IS VOLATILE
0878                               
0879 fb1b 86 11              [ 2 ] BSON    LDA     #$11            ; SET READ CODE
0880 fb1d 6d 66              [ 7 ]         TST     6,S             ; ? READ OR VERIFY
0881 fb1f 26 01              [ 3 ]         BNE     BSON2           ; BRANCH YES
0882 fb21 4c                 [ 2 ]         INCA                    ; SET TO WRITE
0883 fb22 3f                 [19 ] BSON2   SWI                     ; PERFORM OUTPUT
0884 fb23 01                               FCB     OUTCH           ; FUNCTION
0885 fb24 0c 8f              [ 6 ]         INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
0886 fb26 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0887                               
0888                               * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
0889                               * A,X VOLATILE
0890                               
0891 fb27 86 14              [ 2 ] BSOFF   LDA     #$14            ; TO DC4 - STOP
0892 fb29 3f                 [19 ]         SWI                     ; SEND OUT
0893 fb2a 01                               FCB     OUTCH           ; FUNCTION
0894 fb2b 4a                 [ 2 ]         DECA                    ; CHANGE TO DC3 (X-OFF)
0895 fb2c 3f                 [19 ]         SWI                     ; SEND OUT
0896 fb2d 01                               FCB     OUTCH           ; FUNCTION
0897 fb2e 0a 8f              [ 6 ]         DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
0898 fb30 8e 61 a8           [ 3 ]         LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
0899 fb33 30 1f              [ 5 ] BSOFLP  LEAX    -1,X            ; COUNT DOWN
0900 fb35 26 fc              [ 3 ]         BNE     BSOFLP          ; LOOP TILL DONE
0901 fb37 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0902                               
0903                               * BSDTA - READ/VERIFY/PUNCH HANDLER
0904                               * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
0905                               * S+4=START ADDRESS
0906                               * S+2=STOP ADDRESS
0907                               * S+0=RETURN ADDRESS
0908                               * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
0909                               * REGISTERS ARE VOLATILE
0910 fb38 ee 62              [ 6 ] BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
0911 fb3a 6d 66              [ 7 ]         TST     6,S             ; ? PUNCH
0912 fb3c 27 54              [ 3 ]         BEQ     BSDPUN          ; BRANCH YES
0913                               
0914                               * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
0915                               * S+1=BYTE COUNTER
0916                               * S+0=CHECKSUM
0917                               * U HOLDS OFFSET
0918 fb3e 32 7d              [ 5 ]         LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
0919 fb40 3f                 [19 ] BSDLD1  SWI                     ; GET NEXT CHARACTER
0920 fb41 00                               FCB     INCHNP          ; FUNCTION
0921 fb42 81 53              [ 2 ] BSDLD2  CMPA    #'S             ; ? START OF S1/S9
0922 fb44 26 fa              [ 3 ]         BNE     BSDLD1          ; BRANCH NOT
0923 fb46 3f                 [19 ]         SWI                     ; GET NEXT CHARACTER
0924 fb47 00                               FCB     INCHNP          ; FUNCTION
0925 fb48 81 39              [ 2 ]         CMPA    #'9             ; ? HAVE S9
0926 fb4a 27 22              [ 3 ]         BEQ     BSDSRT          ; YES, RETURN GOOD CODE
0927 fb4c 81 31              [ 2 ]         CMPA    #'1             ; ? HAVE NEW RECORD
0928 fb4e 26 f2              [ 3 ]         BNE     BSDLD2          ; BRANCH IF NOT
0929 fb50 6f e4              [ 6 ]         CLR     ,S              ; CLEAR CHECKSUM
0930 fb52 8d 21              [ 7 ]         BSR     BYTE            ; OBTAIN BYTE COUNT
0931 fb54 e7 61              [ 5 ]         STB     1,S             ; SAVE FOR DECREMENT
0932                               
0933                               * READ ADDRESS
0934 fb56 8d 1d              [ 7 ]         BSR     BYTE            ; OBTAIN HIGH VALUE
0935 fb58 e7 62              [ 5 ]         STB     2,S             ; SAVE IT
0936 fb5a 8d 19              [ 7 ]         BSR     BYTE            ; OBTAIN LOW VALUE
0937 fb5c a6 62              [ 5 ]         LDA     2,S             ; MAKE D=VALUE
0938 fb5e 31 cb              [ 8 ]         LEAY    D,U             ; Y=ADDRESS+OFFSET
0939                               * STORE TEXT
0940 fb60 8d 13              [ 7 ] BSDNXT  BSR     BYTE            ; NEXT BYTE
0941 fb62 27 0c              [ 3 ]         BEQ     BSDEOL          ; BRANCH IF CHECKSUM
0942 fb64 6d 69              [ 7 ]         TST     9,S             ; ? VERIFY ONLY
0943 fb66 2b 02              [ 3 ]         BMI     BSDCMP          ; YES, ONLY COMPARE
0944 fb68 e7 a4              [ 4 ]         STB     ,Y              ; STORE INTO MEMORY
0945 fb6a e1 a0              [ 6 ] BSDCMP  CMPB    ,Y+             ; ? VALID RAM
0946 fb6c 27 f2              [ 3 ]         BEQ     BSDNXT          ; YES, CONTINUE READING
0947 fb6e 35 92              [10 ] BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
0948 fb70 4c                 [ 2 ] BSDEOL  INCA                    ; ? VALID CHECKSUM
0949 fb71 27 cd              [ 3 ]         BEQ     BSDLD1          ; BRANCH YES
0950 fb73 20 f9              [ 3 ]         BRA     BSDSRT          ; RETURN Z=0 INVALID
0951                               
0952                               * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
0953 fb75 8d 12              [ 7 ] BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
0954 fb77 c6 10              [ 2 ]         LDB     #16            ; PREPARE SHIFT
0955 fb79 3d                 [11 ]         MUL                    ; OVER TO A
0956 fb7a 8d 0d              [ 7 ]         BSR     BYTHEX         ; OBTAIN SECOND HEX
0957 fb7c 34 04              [ 6 ]         PSHS    B              ; SAVE HIGH HEX
0958 fb7e ab e0              [ 6 ]         ADDA    ,S+            ; COMBINE BOTH SIDES
0959 fb80 1f 89              [ 6 ]         TFR     A,B            ; SEND BACK IN B
0960 fb82 ab 62              [ 5 ]         ADDA    2,S            ; COMPUTE NEW CHECKSUM
0961 fb84 a7 62              [ 5 ]         STA     2,S            ; STORE BACK
0962 fb86 6a 63              [ 7 ]         DEC     3,S            ; DECREMENT BYTE COUNT
0963 fb88 39                 [ 5 ] BYTRTS  RTS                    ; RETURN TO CALLER
0964                               
0965 fb89 3f                 [19 ] BYTHEX  SWI                    ; GET NEXT HEX
0966 fb8a 00                               FCB     INCHNP         ; CHARACTER
0967 fb8b 17 01 d4           [ 9 ]         LBSR    CNVHEX         ; CONVERT TO HEX
0968 fb8e 27 f8              [ 3 ]         BEQ     BYTRTS         ; RETURN IF VALID HEX
0969 fb90 35 f2              [14 ]         PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
0970                               
0971                               * PUNCH STACK USE: S+8=TO ADDRESS
0972                               *                  S+6=RETURN ADDRESS
0973                               *                  S+4=SAVED PADDING VALUES
0974                               *                  S+2 FROM ADDRESS
0975                               *                  S+1=FRAME COUNT/CHECKSUM
0976                               *                  S+0=BYTE COUNT
0977                               
0978 fb92 de f2              [ 5 ] BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
0979 fb94 ae 64              [ 6 ]         LDX     4,S             ; X=FROM ADDRESS
0980 fb96 34 56              [11 ]         PSHS    U,X,D           ; CREATE STACK WORK AREA
0981 fb98 cc 00 18           [ 3 ]         LDD     #24             ; SET A=0, B=24
0982 fb9b d7 f2              [ 4 ]         STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
0983 fb9d 3f                 [19 ]         SWI                     ; SEND NULLS OUT
0984 fb9e 01                               FCB     OUTCH           ; FUNCTION
0985 fb9f c6 04              [ 2 ]         LDB     #4              ; SETUP NEW LINE PAD TO 4
0986 fba1 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
0987                               * CALCULATE SIZE
0988 fba3 ec 68              [ 6 ] BSPGO   LDD     8,S             ; LOAD TO
0989 fba5 a3 62              [ 7 ]         SUBD    2,S             ; MINUS FROM=LENGTH
0990 fba7 10 83 00 18        [ 5 ]         CMPD    #24             ; ? MORE THAN 23
0991 fbab 25 02              [ 3 ]         BLO     BSPOK           ; NO, OK
0992 fbad c6 17              [ 2 ]         LDB     #23             ; FORCE TO 23 MAX
0993 fbaf 5c                 [ 2 ] BSPOK   INCB                    ; PREPARE COUNTER
0994 fbb0 e7 e4              [ 4 ]         STB     ,S              ; STORE BYTE COUNT
0995 fbb2 cb 03              [ 2 ]         ADDB    #3              ; ADJUST TO FRAME COUNT
0996 fbb4 e7 61              [ 5 ]         STB     1,S             ; SAVE
0997                               
0998                               *PUNCH CR,LF,NULS,S,1
0999 fbb6 30 8c 33           [ 5 ]        LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
1000 fbb9 3f                 [19 ]        SWI                      ; SEND OUT
1001 fbba 03                              FCB      PDATA           ; FUNCTION
1002                               * SEND FRAME COUNT
1003 fbbb 5f                 [ 2 ]        CLRB                     ; INITIALIZE CHECKSUM
1004 fbbc 30 61              [ 5 ]        LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
1005 fbbe 8d 27              [ 7 ]        BSR      BSPUN2          ; SEND FRAME COUNT
1006                               *DATA ADDRESS
1007 fbc0 8d 25              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS HI
1008 fbc2 8d 23              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS LOW
1009                               *PUNCH DATA
1010 fbc4 ae 62              [ 6 ]        LDX      2,S             ; LOAD START DATA ADDRESS
1011 fbc6 8d 1f              [ 7 ] BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
1012 fbc8 6a e4              [ 6 ]        DEC      ,S              ; ? FINAL BYTE
1013 fbca 26 fa              [ 3 ]        BNE      BSPMRE          ; LOOP IF NOT DONE
1014 fbcc af 62              [ 6 ]        STX      2,S             ; UPDATE FROM ADDRESS VALUE
1015                               *PUNCH CHECKSUM
1016 fbce 53                 [ 2 ]        COMB                     ; COMPLEMENT
1017 fbcf e7 61              [ 5 ]        STB      1,S             ; STORE FOR SENDOUT
1018 fbd1 30 61              [ 5 ]        LEAX     1,S             ; POINT TO IT
1019 fbd3 8d 14              [ 7 ]        BSR      BSPUNC          ; SEND OUT AS HEX
1020 fbd5 ae 68              [ 6 ]        LDX      8,S             ; LOAD TOP ADDRESS
1021 fbd7 ac 62              [ 7 ]        CMPX     2,S             ; ? DONE
1022 fbd9 24 c8              [ 3 ]        BHS      BSPGO           ; BRANCH NOT
1023 fbdb 30 8c 11           [ 5 ]        LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
1024 fbde 3f                 [19 ]        SWI                      ; SEND OUT STRING
1025 fbdf 03                              FCB      PDATA           ; FUNCTION
1026 fbe0 ec 64              [ 6 ]        LDD      4,S             ; RECOVER PAD COUNTS
1027 fbe2 dd f2              [ 5 ]        STD      <VECTAB+.PAD    ; RESTORE
1028 fbe4 4f                 [ 2 ]        CLRA                     ; SET Z=1 FOR OK RETURN
1029 fbe5 35 d6              [13 ]        PULS     PC,U,X,D        ; RETURN WITH OK CODE
1030 fbe7 eb 84              [ 4 ] BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
1031 fbe9 16 fd ed           [ 5 ] BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
1032                               
1033 fbec 53 01 04                 BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
1034 fbef 53 39 30 33 30 30        BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
1035 fbf9 0d 0a 04                        FCB      CR,LF,EOT
1036                               
1037                               * HSDTA - HIGH SPEED PRINT MEMORY
1038                               * INPUT: S+4=START ADDRESS
1039                               * S+2=STOP ADDRESS
1040                               * S+0=RETURN ADDRESS
1041                               * X,D VOLATILE
1042                               
1043                               * SEND TITLE
1044                               
1045 fbfc 3f                 [19 ] HSDTA   SWI                     ; SEND NEW LINE
1046 fbfd 06                               FCB     PCRLF           ; FUNCTION
1047 fbfe c6 06              [ 2 ]         LDB     #6              ; PREPARE 6 SPACES
1048 fc00 3f                 [19 ] HSBLNK  SWI                     ; SEND BLANK
1049 fc01 07                               FCB     SPACE           ; FUNCTION
1050 fc02 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1051 fc03 26 fb              [ 3 ]         BNE     HSBLNK          ; LOOP IF MORE
1052 fc05 5f                 [ 2 ]         CLRB                    ; SETUP BYTE COUNT
1053 fc06 1f 98              [ 6 ] HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
1054 fc08 17 fd db           [ 9 ]         LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
1055 fc0b 3f                 [19 ]         SWI                     ; SEND BLANK
1056 fc0c 07                               FCB     SPACE           ; FUNCTION
1057 fc0d 3f                 [19 ]         SWI                     ; SEND ANOTHER
1058 fc0e 07                               FCB     SPACE           ; BLANK
1059 fc0f 5c                 [ 2 ]         INCB                    ; UP ANOTHER
1060 fc10 c1 10              [ 2 ]         CMPB    #$10            ; ? PAST 'F'
1061 fc12 25 f2              [ 3 ]         BLO     HSHTTL          ; LOOP UNTIL SO
1062 fc14 3f                 [19 ] HSHLNE  SWI                     ; TO NEXT LINE
1063 fc15 06                               FCB     PCRLF           ; FUNCTION
1064 fc16 25 2f              [ 3 ]         BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
1065 fc18 30 64              [ 5 ]         LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
1066 fc1a 3f                 [19 ]         SWI                     ; PRINT OUT ADDRESS
1067 fc1b 05                               FCB     OUT4HS          ; FUNCTION
1068 fc1c ae 64              [ 6 ]         LDX     4,S             ; LOAD ADDRESS PROPER
1069 fc1e c6 10              [ 2 ]         LDB     #16             ; NEXT SIXTEEN
1070 fc20 3f                 [19 ] HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
1071 fc21 04                               FCB     OUT2HS          ; FUNCTION
1072 fc22 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1073 fc23 26 fb              [ 3 ]         BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
1074 fc25 3f                 [19 ]         SWI                     ; SEND BLANK
1075 fc26 07                               FCB     SPACE           ; FUNCTION
1076 fc27 ae 64              [ 6 ]         LDX     4,S             ; RELOAD FROM ADDRESS
1077 fc29 c6 10              [ 2 ]         LDB     #16             ; COUNT
1078 fc2b a6 80              [ 6 ] HSHCHR  LDA     ,X+             ; NEXT BYTE
1079 fc2d 2b 04              [ 3 ]         BMI     HSHDOT          ; TOO LARGE, TO A DOT
1080 fc2f 81 20              [ 2 ]         CMPA    #'              ; ? LOWER THAN A BLANK
1081 fc31 24 02              [ 3 ]         BHS     HSHCOK          ; NO, BRANCH OK
1082 fc33 86 2e              [ 2 ] HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
1083 fc35 3f                 [19 ] HSHCOK  SWI                     ; SEND CHARACTER
1084 fc36 01                               FCB     OUTCH           ; FUNCTION
1085 fc37 5a                 [ 2 ]         DECB                    ; ? DONE
1086 fc38 26 f1              [ 3 ]         BNE     HSHCHR          ; BRANCH NO
1087 fc3a ac 62              [ 7 ]         CMPX    2,S             ; ? PAST LAST ADDRESS
1088 fc3c 24 09              [ 3 ]         BHS     HSDRTN          ; QUIT IF SO
1089 fc3e af 64              [ 6 ]         STX     4,S             ; UPDATE FROM ADDRESS
1090 fc40 a6 65              [ 5 ]         LDA     5,S             ; LOAD LOW BYTE ADDRESS
1091 fc42 48                 [ 2 ]         ASLA                    ; ? TO SECTION BOUNDARY
1092 fc43 26 cf              [ 3 ]         BNE     HSHLNE          ; BRANCH IF NOT
1093 fc45 20 b5              [ 3 ]         BRA     HSDTA           ; BRANCH IF SO
1094 fc47 3f                 [19 ] HSDRTN  SWI                     ; SEND NEW LINE
1095 fc48 06                               FCB     PCRLF           ; FUNCTION
1096 fc49 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
1097                               *F
1098                               
1099                               ***********************************************
1100                               *     A S S I S T 0 9    C O M M A N D S
1101                               ***********************************************
1102                               
1103                               *************REGISTERS - DISPLAY AND CHANGE REGISTERS
1104 fc4a 8d 23              [ 7 ] CREG    BSR     REGPRT          ; PRINT REGISTERS
1105 fc4c 4c                 [ 2 ]         INCA                    ; SET FOR CHANGE FUNCTION
1106 fc4d 8d 21              [ 7 ]         BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
1107 fc4f 39                 [ 5 ]         RTS                     ; RETURN TO COMMAND PROCESSOR
1108                               
1109                               ********************************************
1110                               * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
1111                               * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
1112                               * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
1113                               * DONE.
1114                               
1115                               * REGISTER MASK LIST CONSISTS OF:
1116                               * A) CHARACTERS DENOTING REGISTER
1117                               * B) ZERO FOR ONE BYTE, -1 FOR TWO
1118                               * C) OFFSET ON STACK TO REGISTER POSITION
1119                               * INPUT: SP+4=STACKED REGISTERS
1120                               * A=0 PRINT, A#0 PRINT AND CHANGE
1121                               * OUTPUT: (ONLY FOR REGISTER DISPLAY)
1122                               * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
1123                               * VOLATILE: D,X (CHANGE)
1124                               * B,X (DISPLAY)
1125                               *******************************************
1126                               
1127 fc50 50 43 ff 13              REGMSK  FCB     'P,'C,-1,19     ; PC REG
1128 fc54 41 00 0a                         FCB     'A,0,10         ; A REG
1129 fc57 42 00 0b                         FCB     'B,0,11         ; B REG
1130 fc5a 58 ff 0d                         FCB     'X,-1,13        ; X REG
1131 fc5d 59 ff 0f                         FCB     'Y,-1,15        ; Y REG
1132 fc60 55 ff 11                         FCB     'U,-1,17        ; U REG
1133 fc63 53 ff 01                         FCB     'S,-1,1         ; S REG
1134 fc66 43 43 00 09                      FCB     'C,'C,0,9       ; CC REG
1135 fc6a 44 50 00 0c                      FCB     'D,'P,0,12      ; DP REG
1136 fc6e 00                               FCB     0               ; END OF LIST
1137                               
1138 fc6f 4f                 [ 2 ] REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
1139 fc70 30 e8 10           [ 5 ] REGCHG  LEAX    4+12,S          ; READY STACK VALUE
1140 fc73 34 32              [10 ]         PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
1141 fc75 31 8c d8           [ 5 ]         LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
1142 fc78 ec a0              [ 7 ] REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
1143 fc7a 4d                 [ 2 ]         TSTA                    ; ? END OF CHARACTERS
1144 fc7b 2f 04              [ 3 ]         BLE     REGP2           ; BRANCH NOT CHARACTER
1145 fc7d 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
1146 fc7e 01                               FCB     OUTCH           ; FUNCTION BYTE
1147 fc7f 20 f7              [ 3 ]         BRA     REGP1           ; CHECK NEXT
1148 fc81 86 2d              [ 2 ] REGP2   LDA     #'-             ; READY '-'
1149 fc83 3f                 [19 ]         SWI                     ; SEND OUT
1150 fc84 01                               FCB     OUTCH           ; WITH OUTCH
1151 fc85 30 e5              [ 5 ]         LEAX    B,S             ; X->REGISTER TO PRINT
1152 fc87 6d e4              [ 6 ]         TST     ,S              ; ? CHANGE OPTION
1153 fc89 26 12              [ 3 ]         BNE     REGCNG          ; BRANCH YES
1154 fc8b 6d 3f              [ 7 ]         TST     -1,Y            ; ? ONE OR TWO BYTES
1155 fc8d 27 03              [ 3 ]         BEQ     REGP3           ; BRANCH ZERO MEANS ONE
1156 fc8f 3f                 [19 ]         SWI                     ; PERFORM WORD HEX
1157 fc90 05                               FCB     OUT4HS          ; FUNCTION
1158 fc91 8c                               FCB     SKIP2           ; SKIP BYTE PRINT
1159 fc92 3f                 [19 ] REGP3   SWI                     ; PERFORM BYTE HEX
1160 fc93 04                               FCB     OUT2HS          ; FUNCTION
1161 fc94 ec a0              [ 7 ] REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
1162 fc96 5d                 [ 2 ]         TSTB                    ; ? END OF ENTRIES
1163 fc97 26 df              [ 3 ]         BNE     REGP1           ; LOOP IF MORE
1164 fc99 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1165 fc9a 06                               FCB     PCRLF           ; FUNCTION
1166 fc9b 35 b2              [12 ] REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
1167                               
1168 fc9d 8d 40              [ 7 ] REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
1169 fc9f 27 10              [ 3 ]         BEQ     REGNXC          ; IF CHANGE THEN JUMP
1170 fca1 81 0d              [ 2 ]         CMPA    #CR             ; ? NO MORE DESIRED
1171 fca3 27 1e              [ 3 ]         BEQ     REGAGN          ; BRANCH NOPE
1172 fca5 e6 3f              [ 5 ]         LDB     -1,Y            ; LOAD SIZE FLAG
1173 fca7 5a                 [ 2 ]         DECB                    ; MINUS ONE
1174 fca8 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
1175 fca9 58                 [ 2 ]         ASLB                    ; TIMES TWO (=2 OR =4)
1176 fcaa 3f                 [19 ] REGSKP  SWI                     ; PERFORM SPACES
1177 fcab 07                               FCB     SPACE           ; FUNCTION
1178 fcac 5a                 [ 2 ]         DECB
1179 fcad 26 fb              [ 3 ]         BNE     REGSKP          ; LOOP IF MORE
1180 fcaf 20 e3              [ 3 ]         BRA     REG4            ; CONTINUE WITH NEXT REGISTER
1181 fcb1 a7 e4              [ 4 ] REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
1182                               *                               ; (ALWAYS > 0)
1183 fcb3 dc 9b              [ 5 ]         LDD     <NUMBER         ; OBTAIN BINARY RESULT
1184 fcb5 6d 3f              [ 7 ]         TST     -1,Y            ; ? TWO BYTES WORTH
1185 fcb7 26 02              [ 3 ]         BNE     REGTWO          ; BRANCH YES
1186 fcb9 a6 82              [ 6 ]         LDA     ,-X             ; SETUP FOR TWO
1187 fcbb ed 84              [ 5 ] REGTWO  STD     ,X              ; STORE IN NEW VALUE
1188 fcbd a6 e4              [ 4 ]         LDA     ,S              ; RECOVER DELIMITER
1189 fcbf 81 0d              [ 2 ]         CMPA    #CR             ; ? END OF CHANGES
1190 fcc1 26 d1              [ 3 ]         BNE     REG4            ; NO, KEEP ON TRUCK'N
1191                               * MOVE STACKED DATA TO NEW STACK IN CASE STACK
1192                               * POINTER HAS CHANGED
1193 fcc3 30 8d e2 8a        [ 9 ] REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
1194 fcc7 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT
1195 fcc9 35 02              [ 6 ] REGTF1  PULS    A               ; NEXT BYTE
1196 fccb a7 80              [ 6 ]         STA     ,X+             ; STORE INTO TEMP
1197 fccd 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1198 fcce 26 f9              [ 3 ]         BNE     REGTF1          ; LOOP IF MORE
1199 fcd0 10 ee 88 ec        [ 7 ]         LDS     -20,X           ; LOAD NEW STACK POINTER
1200 fcd4 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT AGAIN
1201 fcd6 a6 82              [ 6 ] REGTF2 LDA      ,-X             ; NEXT TO STORE
1202 fcd8 34 02              [ 6 ]        PSHS     A               ; BACK ONTO NEW STACK
1203 fcda 5a                 [ 2 ]        DECB                     ; COUNT DOWN
1204 fcdb 26 f9              [ 3 ]        BNE      REGTF2          ; LOOP IF MORE
1205 fcdd 20 bc              [ 3 ]        BRA      REGRTN          ; GO RESTART COMMAND
1206                               
1207                               *********************************************
1208                               * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
1209                               * THE ACTIVE EXPRESSION HANDLER IS USED.
1210                               * INPUT: S=RETURN ADDRESS
1211                               * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
1212                               * (IF DELM NOT ZERO)
1213                               * "NUMBER"=WORD BINARY RESULT
1214                               * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
1215                               * REGISTERS ARE TRANSPARENT
1216                               **********************************************
1217                               * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
1218                               *
1219                               * THE FLAG "DELIM" IS USED AS FOLLOWS:
1220                               * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
1221                               * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
1222 fcdf 4f                 [ 2 ] BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
1223 fce0 8c                               FCB     SKIP2           ; SKIP NEXT INSTRUCTION
1224                               * BUILD WITH LEADING BLANKS
1225 fce1 86 20              [ 2 ] BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
1226 fce3 97 8e              [ 4 ]         STA     <DELIM          ; STORE AS DELIMITER
1227 fce5 6e 9d e3 03        [11 ]         JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
1228                               * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
1229                               * 1) HEX INPUT
1230                               * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
1231                               * 3) 'P' FOR PROGRAM COUNTER ADDRESS
1232                               * 4) 'W' FOR WINDOW VALUE
1233                               * 5) '@' FOR INDIRECT VALUE
1234                               
1235 fce9 34 14              [ 8 ] EXP1    PSHS    X,B             ; SAVE REGISTERS
1236 fceb 8d 5c              [ 7 ] EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
1237 fced 27 18              [ 3 ]         BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
1238                               * SKIP BLANKS IF DESIRED
1239 fcef 91 8e              [ 4 ]         CMPA    <DELIM          ; ? CORRECT DELIMITER
1240 fcf1 27 f8              [ 3 ]         BEQ     EXPDLM          ; YES, IGNORE IT
1241                               * TEST FOR M OR P
1242 fcf3 9e 9e              [ 5 ]         LDX     <ADDR           ; DEFAULT FOR 'M'
1243 fcf5 81 4d              [ 2 ]         CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
1244 fcf7 27 16              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1245 fcf9 9e 93              [ 5 ]         LDX     <PCNTER         ; DEFAULT FOR 'P'
1246 fcfb 81 50              [ 2 ]         CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
1247 fcfd 27 10              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1248 fcff 9e a0              [ 5 ]         LDX     <WINDOW         ; DEFAULT TO WINDOW
1249 fd01 81 57              [ 2 ]         CMPA    #'W             ; ? WINDOW WANTED
1250 fd03 27 0a              [ 3 ]         BEQ     EXPTDL
1251                               
1252 fd05 35 94              [10 ] EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
1253                               * GOT HEX, NOW CONTINUE BUILDING
1254 fd07 8d 44              [ 7 ] EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
1255 fd09 27 fc              [ 3 ]         BEQ     EXP2            ; CONTINUE IF MORE
1256 fd0b 20 0a              [ 3 ]         BRA     EXPCDL          ; SEARCH FOR +/-
1257                               * STORE VALUE AND CHECK IF NEED DELIMITER
1258 fd0d ae 84              [ 5 ] EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
1259 fd0f 9f 9b              [ 5 ] EXPTDL  STX     <NUMBER         ; STORE RESULT
1260 fd11 0d 8e              [ 6 ]         TST     <DELIM          ; ? TO FORCE A DELIMITER
1261 fd13 27 f0              [ 3 ]         BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
1262 fd15 8d 62              [ 7 ]         BSR     READ            ; OBTAIN NEXT CHARACTER
1263                               * TEST FOR + OR -
1264 fd17 9e 9b              [ 5 ] EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
1265 fd19 81 2b              [ 2 ]         CMPA    #'+             ; ? ADD OPERATOR
1266 fd1b 26 0e              [ 3 ]         BNE     EXPCHM          ; BRANCH NOT
1267 fd1d 8d 23              [ 7 ]         BSR     EXPTRM          ; COMPUTE NEXT TERM
1268 fd1f 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1269 fd21 dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NEW TERM
1270 fd23 30 8b              [ 8 ] EXPADD  LEAX    D,X             ; ADD TO X
1271 fd25 9f 9b              [ 5 ]         STX     <NUMBER         ; STORE AS NEW RESULT
1272 fd27 35 02              [ 6 ]         PULS    A               ; RESTORE DELIMITER
1273 fd29 20 ec              [ 3 ]         BRA     EXPCDL          ; NOW TEST IT
1274 fd2b 81 2d              [ 2 ] EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
1275 fd2d 27 07              [ 3 ]         BEQ     EXPSUB          ; BRANCH IF SO
1276 fd2f 81 40              [ 2 ]         CMPA    #'@             ; ? INDIRECTION DESIRED
1277 fd31 27 da              [ 3 ]         BEQ     EXPTDI          ; BRANCH IF SO
1278 fd33 5f                 [ 2 ]         CLRB                    ; SET DELIMITER RETURN
1279 fd34 20 cf              [ 3 ]         BRA     EXPRTN          ; AND RETURN TO CALLER
1280 fd36 8d 0a              [ 7 ] EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
1281 fd38 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1282 fd3a dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD UP NEXT TERM
1283 fd3c 40                 [ 2 ]         NEGA                    ; NEGATE A
1284 fd3d 50                 [ 2 ]         NEGB                    ; NEGATE B
1285 fd3e 82 00              [ 2 ]         SBCA    #0              ; CORRECT FOR A
1286 fd40 20 e1              [ 3 ]         BRA     EXPADD          ; GO ADD TO EXPRESSION
1287                               * COMPUTE NEXT EXPRESSION TERM
1288                               * OUTPUT: X=OLD VALUE
1289                               * 'NUMBER'=NEXT TERM
1290 fd42 8d 9d              [ 7 ] EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
1291 fd44 27 32              [ 3 ]         BEQ     CNVRTS          ; RETURN IF VALID NUMBER
1292 fd46 16 fc 13           [ 5 ] BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
1293                               
1294                               *********************************************
1295                               * BUILD BINARY VALUE USING INPUT CHARACTERS.
1296                               * INPUT: A=ASCII HEX VALUE OR DELIMITER
1297                               * SP+0=RETURN ADDRESS
1298                               * SP+2=16 BIT RESULT AREA
1299                               * OUTPUT: Z=1 A=BINARY VALUE
1300                               * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
1301                               * VOLATILE: D
1302                               ****************************************
1303 fd49 0f 9b              [ 6 ] BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
1304 fd4b 0f 9c              [ 6 ]         CLR     <NUMBER+1       ; CLEAR NUMBER
1305 fd4d 8d 2a              [ 7 ] BLDHEX  BSR     READ            ; GET INPUT CHARACTER
1306 fd4f 8d 11              [ 7 ] BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
1307 fd51 26 25              [ 3 ]         BNE     CNVRTS          ; RETURN IF NOT A NUMBER
1308 fd53 c6 10              [ 2 ]         LDB     #16             ; PREPARE SHIFT
1309 fd55 3d                 [11 ]         MUL                     ; BY FOUR PLACES
1310 fd56 86 04              [ 2 ]         LDA     #4              ; ROTATE BINARY INTO VALUE
1311 fd58 58                 [ 2 ] BLDSHF  ASLB                    ; OBTAIN NEXT BIT
1312 fd59 09 9c              [ 6 ]         ROL     <NUMBER+1       ; INTO LOW BYTE
1313 fd5b 09 9b              [ 6 ]         ROL     <NUMBER         ; INTO HI BYTE
1314 fd5d 4a                 [ 2 ]         DECA                    ; COUNT DOWN
1315 fd5e 26 f8              [ 3 ]         BNE     BLDSHF          ; BRANCH IF MORE TO DO
1316 fd60 20 14              [ 3 ]         BRA     CNVOK           ; SET GOOD RETURN CODE
1317                               
1318                               ****************************************
1319                               * CONVERT ASCII CHARACTER TO BINARY BYTE
1320                               * INPUT: A=ASCII
1321                               * OUTPUT: Z=1 A=BINARY VALUE
1322                               * Z=0 IF INVALID
1323                               * ALL REGISTERS TRANSPARENT
1324                               * (A UNALTERED IF INVALID HEX)
1325                               **************************************
1326 fd62 81 30              [ 2 ] CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
1327 fd64 25 12              [ 3 ]         BLO     CNVRTS          ; BRANCH NOT VALUE
1328 fd66 81 39              [ 2 ]         CMPA    #'9             ; ? POSSIBLE A-F
1329 fd68 2f 0a              [ 3 ]         BLE     CNVGOT          ; BRANCH NO TO ACCEPT
1330 fd6a 81 41              [ 2 ]         CMPA    #'A             ; ? LESS THEN TEN
1331 fd6c 25 0a              [ 3 ]         BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
1332 fd6e 81 46              [ 2 ]         CMPA    #'F             ; ? NOT TOO LARGE
1333 fd70 22 06              [ 3 ]         BHI     CNVRTS          ; NO, RETURN TOO LARGE
1334 fd72 80 07              [ 2 ]         SUBA    #7              ; DOWN TO BINARY
1335 fd74 84 0f              [ 2 ] CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
1336 fd76 1a 04              [ 3 ] CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
1337 fd78 39                 [ 5 ] CNVRTS  RTS                     ; RETURN TO CALLER
1338                               
1339                               * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
1340 fd79 3f                 [19 ] READ     SWI                    ; GET NEXT CHARACTER
1341 fd7a 00                                FCB    INCHNP          ; FUNCTION
1342 fd7b 81 18              [ 2 ]          CMPA   #CAN            ; ? ABORT COMMAND
1343 fd7d 27 c7              [ 3 ]          BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
1344 fd7f 39                 [ 5 ]          RTS                    ; RETURN TO CALLER
1345                               *G
1346                               
1347                               ***************GO - START PROGRAM EXECUTION
1348 fd80 8d 01              [ 7 ] CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
1349 fd82 3b                 [15 ]          RTI                    ; START EXECUTING
1350                               
1351                               * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
1352                               * BREAKPOINTS.
1353 fd83 35 30              [ 9 ] GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
1354 fd85 34 10              [ 7 ]          PSHS   X               ; STORE RETURN BACK
1355 fd87 26 19              [ 3 ]          BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
1356                               
1357                               * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
1358                               * IMMEDIATE BREAKPOINT.
1359 fd89 17 01 b6           [ 9 ]          LBSR   CBKLDR          ; SEARCH BREAKPOINTS
1360 fd8c ae 6c              [ 6 ]          LDX    12,S            ; LOAD PROGRAM COUNTER
1361 fd8e 5a                 [ 2 ] ARMBLP  DECB                    ; COUNT DOWN
1362 fd8f 2b 16              [ 3 ]         BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
1363 fd91 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
1364 fd93 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
1365 fd95 26 f7              [ 3 ]         BNE     ARMBLP          ; LOOP IF NOT
1366 fd97 81 3f              [ 2 ]         CMPA    #$3F            ; ? SWI BREAKPOINTED
1367 fd99 26 02              [ 3 ]         BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
1368 fd9b 97 fb              [ 4 ]         STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
1369 fd9d 0c 8f              [ 6 ] ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
1370 fd9f 16 01 06           [ 5 ]         LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
1371                               
1372                               * OBTAIN NEW PROGRAM COUNTER
1373 fda2 17 00 bb           [ 9 ] GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
1374 fda5 ed 6c              [ 6 ]         STD     12,S            ; STORE INTO STACK
1375 fda7 17 01 98           [ 9 ] ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
1376 fdaa 00 fa              [ 6 ]         NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
1377 fdac 5a                 [ 2 ] ARMLOP  DECB                    ; ? DONE
1378 fdad 2b c9              [ 3 ]         BMI     CNVRTS          ; RETURN WHEN DONE
1379 fdaf a6 b4              [ 7 ]         LDA     [,Y]            ; LOAD OPCODE
1380 fdb1 a7 30              [ 5 ]         STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
1381 fdb3 86 3f              [ 2 ]         LDA     #$3F            ; READY "SWI" OPCODE
1382 fdb5 a7 b1              [10 ]         STA     [,Y++]          ; STORE AND MOVE UP TABLE
1383 fdb7 20 f3              [ 3 ]         BRA     ARMLOP          ; AND CONTINUE
1384                               
1385                               *******************CALL - CALL ADDRESS AS SUBROUTINE
1386 fdb9 8d c8              [ 7 ] CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
1387 fdbb 35 7f              [15 ]         PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
1388 fdbd ad f1              [13 ]         JSR     [,S++]          ; CALL USER SUBROUTINE
1389 fdbf 3f                 [19 ] CGOBRK  SWI                     ; PERFORM BREAKPOINT
1390 fdc0 0a                               FCB     BRKPT           ; FUNCTION
1391 fdc1 20 fc              [ 3 ]         BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
1392                               
1393                               ****************MEMORY - DISPLAY/CHANGE MEMORY
1394                               * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
1395                               * THE COMMAND HANDLER FOR QUICK COMMANDS
1396 fdc3 17 00 9a           [ 9 ] CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
1397 fdc6 dd 9e              [ 5 ] CMEMN   STD     <ADDR           ; STORE DEFAULT
1398 fdc8 9e 9e              [ 5 ] CMEM2   LDX     <ADDR           ; LOAD POINTER
1399 fdca 17 fc 0c           [ 9 ]         LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
1400 fdcd 86 2d              [ 2 ]         LDA     #'-             ; LOAD DELIMITER
1401 fdcf 3f                 [19 ]         SWI                     ; SEND OUT
1402 fdd0 01                               FCB     OUTCH           ; FUNCTION
1403 fdd1 17 ff 0b           [ 9 ] CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
1404 fdd4 27 0a              [ 3 ]         BEQ     CMENUM          ; BRANCH IF NUMBER
1405                               * COMA - SKIP BYTE
1406 fdd6 81 2c              [ 2 ]         CMPA    #',             ; ? COMMA
1407 fdd8 26 0e              [ 3 ]         BNE     CMNOTC          ; BRANCH NOT
1408 fdda 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1409 fddc 30 01              [ 5 ]         LEAX    1,X             ; TO NEXT BYTE
1410 fdde 20 f1              [ 3 ]         BRA     CMEM4           ; AND INPUT IT
1411 fde0 d6 9c              [ 4 ] CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
1412 fde2 8d 47              [ 7 ]         BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
1413 fde4 81 2c              [ 2 ]         CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
1414 fde6 27 e9              [ 3 ]         BEQ     CMEM4           ; BRANCH YES
1415                               * QUOTED STRING
1416 fde8 81 27              [ 2 ] CMNOTC  CMPA    #$27            ; ? QUOTED STRING
1417 fdea 26 0c              [ 3 ]         BNE     CMNOTQ          ; BRANCH NO
1418 fdec 8d 8b              [ 7 ] CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
1419 fdee 81 27              [ 2 ]         CMPA    #$27            ; ? END OF QUOTED STRING
1420 fdf0 27 0c              [ 3 ]         BEQ     CMSPCE          ; YES, QUIT STRING MODE
1421 fdf2 1f 89              [ 6 ]         TFR     A,B             ; TO B FOR SUBROUTINE
1422 fdf4 8d 35              [ 7 ]         BSR     MUPDAT          ; GO UPDATE BYTE
1423 fdf6 20 f4              [ 3 ]         BRA     CMESTR          ; GET NEXT CHARACTER
1424                               * BLANK - NEXT BYTE
1425 fdf8 81 20              [ 2 ] CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
1426 fdfa 26 06              [ 3 ]         BNE     CMNOTB          ; BRANCH NOT
1427 fdfc 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1428 fdfe 3f                 [19 ] CMSPCE  SWI                     ; GIVE SPACE
1429 fdff 07                               FCB     SPACE           ; FUNCTION
1430 fe00 20 c6              [ 3 ]         BRA     CMEM2           ; NOW PROMPT FOR NEXT
1431                               
1432                               * LINE FEED - NEXT BYTE WITH ADDRESS
1433 fe02 81 0a              [ 2 ] CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
1434 fe04 26 08              [ 3 ]         BNE     CMNOTL          ; BRANCH NO
1435 fe06 86 0d              [ 2 ]         LDA     #CR             ; GIVE CARRIAGE RETURN
1436 fe08 3f                 [19 ]         SWI                     ; TO CONSOLE
1437 fe09 01                               FCB     OUTCH           ; HANDLER
1438 fe0a 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEXT ADDRESS
1439 fe0c 20 0a              [ 3 ]         BRA     CMPADP          ; BRANCH TO SHOW
1440                               
1441                               * UP ARROW - PREVIOUS BYTE AND ADDRESS
1442 fe0e 81 5e              [ 2 ] CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
1443 fe10 26 0a              [ 3 ]         BNE     CMNOTU          ; BRANCH NOT
1444 fe12 30 1e              [ 5 ]         LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
1445 fe14 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER
1446 fe16 3f                 [19 ] CMPADS  SWI                     ; FORCE NEW LINE
1447 fe17 06                               FCB     PCRLF           ; FUNCTION
1448 fe18 8d 07              [ 7 ] CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
1449 fe1a 20 ac              [ 3 ]         BRA     CMEM2           ; THEN PROMPT FOR INPUT
1450                               
1451                               * SLASH - NEXT BYTE WITH ADDRESS
1452 fe1c 81 2f              [ 2 ] CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
1453 fe1e 27 f6              [ 3 ]         BEQ     CMPADS          ; YES, SEND ADDRESS
1454 fe20 39                 [ 5 ]         RTS                     ; RETURN FROM COMMAND
1455                               
1456                               * PRINT CURRENT ADDRESS
1457 fe21 9e 9e              [ 5 ] PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
1458 fe23 34 10              [ 7 ]         PSHS    X               ; SAVE X ON STACK
1459 fe25 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT FOR DISPLAY
1460 fe27 3f                 [19 ]         SWI                     ; DISPLAY POINTER IN HEX
1461 fe28 05                               FCB     OUT4HS          ; FUNCTION
1462 fe29 35 90              [ 9 ]         PULS    PC,X            ; RECOVER POINTER AND RETURN
1463                               
1464                               * UPDATE BYTE
1465 fe2b 9e 9e              [ 5 ] MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
1466 fe2d e7 80              [ 6 ]         STB     ,X+             ; STORE AND INCREMENT X
1467 fe2f e1 1f              [ 5 ]         CMPB    -1,X            ; ? SUCCESFULL STORE
1468 fe31 26 03              [ 3 ]         BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
1469 fe33 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER VALUE
1470 fe35 39                 [ 5 ]         RTS                     ; BACK TO CALLER
1471 fe36 34 02              [ 6 ] MUPBAD  PSHS    A               ; SAVE A REGISTER
1472 fe38 86 3f              [ 2 ]         LDA     #'?             ; SHOW INVALID
1473 fe3a 3f                 [19 ]         SWI                     ; SEND OUT
1474 fe3b 01                               FCB     OUTCH           ; FUNCTION
1475 fe3c 35 82              [ 8 ]         PULS    PC,A            ; RETURN TO CALLER
1476                               
1477                               ********************WINDOW - SET WINDOW VALUE
1478 fe3e 8d 20              [ 7 ] CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
1479 fe40 dd a0              [ 5 ]         STD     <WINDOW         ; STORE IT IN
1480 fe42 39                 [ 5 ]         RTS                     ; END COMMAND
1481                               
1482                               ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
1483 fe43 8d 1b              [ 7 ] CDISP   BSR     CDNUM           ; FETCH ADDRESS
1484 fe45 c4 f0              [ 2 ]         ANDB    #$F0            ; FORCE TO 16 BOUNDARY
1485 fe47 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1486 fe49 30 2f              [ 5 ]         LEAX    15,Y            ; DEFAULT LENGTH
1487 fe4b 25 04              [ 3 ]         BCS     CDISPS          ; BRANCH IF END OF INPUT
1488 fe4d 8d 11              [ 7 ]         BSR     CDNUM           ; OBTAIN COUNT
1489 fe4f 30 ab              [ 8 ]         LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
1490 fe51 34 30              [ 9 ] CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
1491 fe53 10 a3 62           [ 8 ]         CMPD    2,S             ; ? WAS IT COUNT
1492 fe56 23 02              [ 3 ]         BLS     CDCNT           ; BRANCH YES
1493 fe58 ed e4              [ 5 ]         STD     ,S              ; STORE HIGH ADDRESS
1494 fe5a ad 9d e1 84        [15 ] CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
1495 fe5e 35 e0              [11 ]         PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
1496                               
1497                               * OBTAIN NUMBER - ABORT IF NONE
1498                               * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
1499                               * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
1500                               * ELSE C=0
1501 fe60 17 fe 7e           [ 9 ] CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
1502 fe63 26 09              [ 3 ]         BNE     CDBADN          ; BRANCH IF INVALID
1503 fe65 81 2f              [ 2 ]         CMPA    #'/             ; ? VALID DELIMITER
1504 fe67 22 05              [ 3 ]         BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
1505 fe69 81 0e              [ 2 ]         CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
1506 fe6b dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER
1507 fe6d 39                 [ 5 ]         RTS                     ; RETURN WITH COMPARE
1508 fe6e 16 fa eb           [ 5 ] CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
1509                               
1510                               *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
1511 fe71 8d ed              [ 7 ] CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
1512 fe73 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1513 fe75 8d e9              [ 7 ]         BSR     CDNUM           ; OBTAIN END ADDRESS
1514 fe77 6f e2              [ 8 ]         CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
1515 fe79 34 26              [ 9 ]         PSHS    Y,D             ; STORE VALUES ON STACK
1516 fe7b ad 9d e1 65        [15 ] CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
1517 fe7f ad 9d e1 63        [15 ]         JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
1518 fe83 34 01              [ 6 ]         PSHS    CC              ; SAVE RETURN CODE
1519 fe85 ad 9d e1 5f        [15 ]         JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
1520 fe89 35 01              [ 6 ]         PULS    CC              ; OBTAIN CONDITION CODE SAVED
1521 fe8b 26 e1              [ 3 ]         BNE     CDBADN          ; BRANCH IF ERROR
1522 fe8d 35 b2              [12 ]         PULS    PC,Y,X,A        ; RETURN FROM COMMAND
1523                               
1524                               *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
1525 fe8f 8d 01              [ 7 ] CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
1526 fe91 01                               FCB     1               ; LOAD FUNCTION CODE FOR PACKET
1527                               
1528 fe92 33 f1              [10 ] CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
1529 fe94 33 d4              [ 7 ]         LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
1530 fe96 27 03              [ 3 ]         BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
1531 fe98 8d c6              [ 7 ]         BSR     CDNUM           ; OBTAIN OFFSET
1532 fe9a 8c                               FCB     SKIP2           ; SKIP DEFAULT OFFSET
1533 fe9b 4f                 [ 2 ] CLVDFT  CLRA                    ; CREATE ZERO OFFSET
1534 fe9c 5f                 [ 2 ]         CLRB                    ; AS DEFAULT
1535 fe9d 34 4e              [10 ]         PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
1536 fe9f 20 da              [ 3 ]         BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
1537                               
1538                               ******************VERIFY - COMPARE MEMORY WITH FILES
1539 fea1 8d ef              [ 7 ] CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
1540 fea3 ff                               FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
1541                               
1542                               *******************TRACE - TRACE INSTRUCTIONS
1543                               ******************* . - SINGLE STEP TRACE
1544 fea4 8d ba              [ 7 ] CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
1545 fea6 dd 91              [ 5 ]         STD     <TRACEC         ; STORE COUNT
1546 fea8 32 62              [ 5 ] CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
1547 feaa ee f8 0a           [ 9 ] CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
1548 fead df 99              [ 5 ]         STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
1549 feaf de f6              [ 5 ]         LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
1550 feb1 cc 07 01           [ 3 ]         LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
1551 feb4 ed 42              [ 6 ]         STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
1552 feb6 3b                 [15 ]         RTI                     ; RETURN FOR ONE INSTRUCTION
1553                               
1554                               *************NULLS  -  SET NEW LINE AND CHAR PADDING
1555 feb7 8d a7              [ 7 ] CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
1556 feb9 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; RESET VALUES
1557 febb 39                 [ 5 ]         RTS                     ; END COMMAND
1558                               
1559                               ******************STLEVEL - SET STACK TRACE LEVEL
1560 febc 27 05              [ 3 ] CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
1561 febe 8d a0              [ 7 ]         BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
1562 fec0 dd f8              [ 5 ]         STD     <SLEVEL         ; STORE NEW ENTRY
1563 fec2 39                 [ 5 ]         RTS                     ; TO COMMAND HANDLER
1564 fec3 30 6e              [ 5 ] STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
1565 fec5 9f f8              [ 5 ]         STX     <SLEVEL         ; AND STORE IT
1566 fec7 39                 [ 5 ]         RTS                     ; END COMMAND
1567                               
1568                               ******************OFFSET - COMPUTE SHORT AND LONG
1569                               ******************                  BRANCH OFFSETS
1570 fec8 8d 96              [ 7 ] COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
1571 feca 1f 01              [ 6 ]         TFR     D,X             ; USE AS FROM ADDRESS
1572 fecc 8d 92              [ 7 ]         BSR     CDNUM           ; OBTAIN TO ADDRESS
1573                               * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
1574 fece 30 01              [ 5 ]         LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
1575 fed0 34 30              [ 9 ]         PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
1576 fed2 a3 e4              [ 6 ]         SUBD    ,S              ; FIND OFFSET
1577 fed4 ed e4              [ 5 ]         STD     ,S              ; SAVE OVER STACK
1578 fed6 30 61              [ 5 ]         LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
1579 fed8 1d                 [ 2 ]         SEX                     ; SIGN EXTEND LOW BYTE
1580 fed9 a1 e4              [ 4 ]         CMPA    ,S              ; ? VALID ONE BYTE OFFSET
1581 fedb 26 02              [ 3 ]         BNE     COFNO1          ; BRANCH IF NOT
1582 fedd 3f                 [19 ]         SWI                     ; SHOW ONE BYTE OFFSET
1583 fede 04                               FCB     OUT2HS          ; FUNCTION
1584 fedf ee e4              [ 5 ] COFNO1  LDU     ,S              ; RELOAD OFFSET
1585 fee1 33 5f              [ 5 ]         LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
1586 fee3 ef 84              [ 5 ]         STU     ,X              ; STORE BACK WHERE X POINTS NOW
1587 fee5 3f                 [19 ]         SWI                     ; SHOW TWO BYTE OFFSET
1588 fee6 05                               FCB     OUT4HS          ; FUNCTION
1589 fee7 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1590 fee8 06                               FCB     PCRLF           ; FUNCTION
1591 fee9 35 96              [11 ]         PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
1592                               *H
1593                               
1594                               *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
1595                               *************             BREAKPOINTS
1596 feeb 27 23              [ 3 ] CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
1597 feed 17 fd f1           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
1598 fef0 27 2c              [ 3 ]         BEQ     CBKADD          ; BRANCH TO ADD IF SO
1599 fef2 81 2d              [ 2 ]         CMPA    #'-             ; ? CORRECT DELIMITER
1600 fef4 26 3f              [ 3 ]         BNE     CBKERR          ; NO, BRANCH FOR ERROR
1601 fef6 17 fd e8           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
1602 fef9 27 03              [ 3 ]         BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
1603 fefb 0f fa              [ 6 ]         CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
1604 fefd 39                 [ 5 ] CBKRTS  RTS                     ; END COMMAND
1605                               * DELETE THE ENTRY
1606 fefe 8d 40              [ 7 ] CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
1607 ff00 5a                 [ 2 ] CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
1608 ff01 2b 32              [ 3 ]         BMI     CBKERR          ; BRANCH NO, ERROR
1609 ff03 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS THE ENTRY
1610 ff05 26 f9              [ 3 ]         BNE     CBKDLP          ; NO, TRY NEXT
1611                               * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
1612 ff07 ae a1              [ 8 ] CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
1613 ff09 af 3c              [ 6 ]         STX     -4,Y            ; MOVE DOWN BY ONE
1614 ff0b 5a                 [ 2 ]         DECB                    ; ? DONE
1615 ff0c 2a f9              [ 3 ]         BPL     CBKDLM          ; NO, CONTINUE MOVE
1616 ff0e 0a fa              [ 6 ]         DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
1617 ff10 8d 2e              [ 7 ] CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
1618 ff12 27 e9              [ 3 ]         BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
1619 ff14 30 a1              [ 7 ] CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
1620 ff16 3f                 [19 ]         SWI                     ; DISPLAY IN HEX
1621 ff17 05                               FCB     OUT4HS          ; FUNCTION
1622 ff18 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1623 ff19 26 f9              [ 3 ]         BNE     CBKDSL          ; LOOP IF NGABLE RAM
1624 ff1b 3f                 [19 ]         SWI                     ; SKIP TO NEW LINK
1625 ff1c 06                               FCB     PCRLF           ; FUNCTIONRTS
1626 ff1d 39                 [ 5 ]         RTS
1627                               
1628                               * ADD NEW ENTRY
1629 ff1e 8d 20              [ 7 ] CBKADD  BSR     CBKSET          ; SETUP REGISTERS
1630 ff20 c1 08              [ 2 ]         CMPB    #NUMBKP         ; ? ALREADY FULL
1631 ff22 27 11              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1632 ff24 a6 84              [ 4 ]         LDA     ,X              ; LOAD BYTE TO TRAP
1633 ff26 e7 84              [ 4 ]         STB     ,X              ; TRY TO CHANGE
1634 ff28 e1 84              [ 4 ]         CMPB    ,X              ; ? CHANGEABLE RAM
1635 ff2a 26 09              [ 3 ]         BNE     CBKERR          ; BRANCH ERROR IF NOT
1636 ff2c a7 84              [ 4 ]         STA ,X                  ; RESTORE BYTE
1637 ff2e 5a                 [ 2 ] CBKADL  DECB                    ; COUNT DOWN
1638 ff2f 2b 07              [ 3 ]         BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
1639 ff31 ac a1              [ 9 ]         CMPX    ,Y++            ; ? ENTRY ALREADY HERE
1640 ff33 26 f9              [ 3 ]         BNE     CBKADL          ; LOOP IF NOT
1641 ff35 16 fa 24           [ 5 ] CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
1642 ff38 af a4              [ 5 ] CBKADT  STX ,Y                  ; ADD THIS ENTRY
1643 ff3a 6f 31              [ 7 ]         CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
1644 ff3c 0c fa              [ 6 ]         INC     <BKPTCT         ; ADD ONE TO COUNT
1645 ff3e 20 d0              [ 3 ]         BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
1646                               * SETUP REGISTERS FOR SCAN
1647 ff40 9e 9b              [ 5 ] CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
1648 ff42 31 8d e0 6c        [ 9 ] CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
1649 ff46 d6 fa              [ 4 ]         LDB     <BKPTCT         ; LOAD ENTRY COUNT
1650 ff48 39                 [ 5 ]         RTS                     ; RETURN
1651                               
1652                               *****************ENCODE  -  ENCODE A POSTBYTE
1653 ff49 6f e2              [ 8 ] CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
1654 ff4b 5f                 [ 2 ]         CLRB                    ; ZERO POSTBYTE VALUE
1655 ff4c 30 8c 3f           [ 5 ]         LEAX    <CONV1,PCR      ; START TABLE SEARCH
1656 ff4f 3f                 [19 ]         SWI                     ; OBTAIN FIRST CHARACTER
1657 ff50 00                               FCB     INCHNP          ; FUNCTION
1658 ff51 81 5b              [ 2 ]         CMPA    #'[             ; ? INDIRECT HERE
1659 ff53 26 06              [ 3 ]         BNE     CEN2            ; BRANCH IF NOT
1660 ff55 86 10              [ 2 ]         LDA     #$10            ; SET INDIRECT BIT ON
1661 ff57 a7 e4              [ 4 ]         STA     ,S              ; SAVE FOR LATER
1662 ff59 3f                 [19 ] CENGET  SWI                     ; OBTAIN NEXT CHARACTER
1663 ff5a 00                               FCB     INCHNP          ; FUNCTION
1664 ff5b 81 0d              [ 2 ] CEN2    CMPA    #CR             ; ? END OF ENTRY
1665 ff5d 27 0c              [ 3 ]         BEQ     CEND1           ; BRANCH YES
1666 ff5f 6d 84              [ 6 ] CENLP1  TST     ,X              ; ? END OF TABLE
1667 ff61 2b d2              [ 3 ]         BMI     CBKERR          ; BRANCH ERROR IF SO
1668 ff63 a1 81              [ 7 ]         CMPA    ,X++            ; ? THIS THE CHARACTER
1669 ff65 26 f8              [ 3 ]         BNE     CENLP1          ; BRANCH IF NOT
1670 ff67 eb 1f              [ 5 ]         ADDB    -1,X            ; ADD THIS VALUE
1671 ff69 20 ee              [ 3 ]         BRA     CENGET          ; GET NEXT INPUT
1672 ff6b 30 8c 49           [ 5 ] CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
1673 ff6e 1f 98              [ 6 ]         TFR     B,A             ; SAVE COPY IN A
1674 ff70 84 60              [ 2 ]         ANDA    #$60            ; ISOLATE REGISTER MASK
1675 ff72 aa e4              [ 4 ]         ORA     ,S              ; ADD IN INDIRECTION BIT
1676 ff74 a7 e4              [ 4 ]         STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
1677 ff76 c4 9f              [ 2 ]         ANDB    #$9F            ; CLEAR REGISTER BITS
1678 ff78 6d 84              [ 6 ] CENLP2  TST     ,X              ; ? END OF TABLE
1679 ff7a 27 b9              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1680 ff7c e1 81              [ 7 ]         CMPB    ,X++            ; ? SAME VALUE
1681 ff7e 26 f8              [ 3 ]         BNE     CENLP2          ; LOOP IF NOT
1682 ff80 e6 1f              [ 5 ]         LDB     -1,X            ; LOAD RESULT VALUE
1683 ff82 ea e4              [ 4 ]         ORB     ,S              ; ADD TO BASE SKELETON
1684 ff84 e7 e4              [ 4 ]         STB     ,S              ; SAVE POSTBYTE ON STACK
1685 ff86 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT
1686 ff88 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
1687 ff89 04                               FCB     OUT2HS          ; FUNCTION
1688 ff8a 3f                 [19 ]         SWI                     ; TO NEXT LINE
1689 ff8b 06                               FCB     PCRLF           ; FUNCTION
1690 ff8c 35 84              [ 8 ]         PULS    PC,B            ; END OF COMMAND
1691                               
1692                               * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
1693                               CONV1
1694 ff8e 41 04 42 05 44 06                FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
1695 ff96 48 01 48 01 48 00                FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
1696 ff9e 2d 09 2d 01 53 70                FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
1697 ffa6 55 50 58 10 2b 07                FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
1698 ffae 50 80 43 00 52 00                FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
1699 ffb6 ff                               FCB     $FF             ; END OF TABLE
1700                               
1701                               * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
1702                               * BIT SKELETON.
1703                               CONV2
1704 ffb7 10 84 11 00                      FDB     $1084,$1100     ; R,      H,R
1705 ffbb 12 88 13 89                      FDB     $1288,$1389     ; HH,R    HHHH,R
1706 ffbf 14 86 15 85                      FDB     $1486,$1585     ; A,R     B,R
1707 ffc3 16 8b 17 80                      FDB     $168B,$1780     ; D,R     ,R+
1708 ffc7 18 81 19 82                      FDB     $1881,$1982     ; ,R++    ,-R
1709 ffcb 1a 83 82 8c                      FDB     $1A83,$828C     ; ,--R    HH,PCR
1710 ffcf 83 8d 03 9f                      FDB     $838D,$039F     ; HHHH,PCR [HHHH]
1711 ffd3 00                               FCB     0               ; END OF TABLE
1712                               
1713                               ****************************************************
1714                               *            DEFAULT INTERRUPT TRANSFERS           *
1715                               ****************************************************
1716 ffd4 6e 9d df ee        [11 ] RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
1717 ffd8 6e 9d df ec        [11 ] SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
1718 ffdc 6e 9d df ea        [11 ] SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
1719 ffe0 6e 9d df e8        [11 ] FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
1720 ffe4 6e 9d df e6        [11 ] IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
1721 ffe8 6e 9d df e4        [11 ] SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
1722 ffec 6e 9d df e2        [11 ] NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
1723                               
1724                               ******************************************************
1725                               *            ASSIST09 HARDWARE VECTOR TABLE
1726                               * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
1727                               * THE MC6809 HARDWARE VECTORS.
1728                               ******************************************************
1729 fff0                                  ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
1730 fff0 ff d4                            FDB     RSRVD           ; RESERVED SLOT
1731 fff2 ff d8                            FDB     SWI3            ; SOFTWARE INTERRUPT 3
1732 fff4 ff dc                            FDB     SWI2            ; SOFTWARE INTERRUPT 2
1733 fff6 ff e0                            FDB     FIRQ            ; FAST INTERRUPT REQUEST
1734 fff8 ff e4                            FDB     IRQ             ; INTERRUPT REQUEST
1735 fffa ff e8                            FDB     SWI             ; SOFTWARE INTERRUPT
1736 fffc ff ec                            FDB     NMI             ; NON-MASKABLE INTERRUPT
1737 fffe f8 37                            FDB     RESET           ; RESTART
